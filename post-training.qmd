---
title: "Post-Training for Foundation Models"
format: html
---

## Introduction: Why Post-Training Matters for Reasoning

Large language models like GPT-4 and Claude have demonstrated impressive capabilities across a wide range of tasks, including writing, summarization, problem solving, and open-ended reasoning. These are examples of **foundation models**—large, general-purpose models trained on broad data at scale, designed to serve as flexible building blocks for many downstream applications. But their raw, pre-trained form is not sufficient for safe, reliable deployment.

The core limitation lies in how LLMs are initially trained. They don’t follow strict rules or formal logic. Instead, they learn from statistical patterns in massive text corpora. This makes them flexible and creative—but also means their reasoning can be inconsistent, misleading, or untrustworthy.

These models are typically optimized to predict the next word in a sentence—not to follow instructions, act ethically, or meet human expectations. This initial phase is called **pre-training**, and it focuses on token-level quality—generating the most likely next word given the prior context. But users care more about the quality of the entire response than just the next token.

This is where **post-training** comes in. It refines the model’s behavior to be helpful, safe, and aligned with human intent. Some compare pre-training to reading a vast amount of text, and post-training to learning how to apply that knowledge in a useful, trustworthy way.

Post-training typically involves two key stages:

- **Supervised Fine-Tuning (SFT)**: teaching the model to follow instructions and carry out tasks
- **Preference Optimization**: aligning outputs with human feedback using methods like RLHF, DPO, or RLAIF

These techniques not only improve factual accuracy and safety, but also enhance the model’s ability to reason. And surprisingly, they require relatively little compute—InstructGPT, for example, used only 2% of its total compute budget for post-training.

While supervised and preference tuning are the core of post-training, it’s also important to consider **prompting techniques**. These methods—such as **zero-shot**, **few-shot**, and **chain-of-thought** prompting—don’t change the model’s weights but can steer its behavior at inference time. Prompting often delivers strong results without additional training, making it an essential part of real-world LLM deployment.

In the sections that follow, we’ll explore both post-training techniques and prompting strategies, and how they work together to transform general-purpose LLMs into dependable, aligned assistants.

![**Figure:** High-level taxonomy of large language model (LLM) post-training strategies, showing where scaling methods (bottom right) fit alongside reinforcement, tuning, and alignment approaches. *(Source: Kumar et al., 2023)*](images/post-training-methods.png){fig-align="center" width="800"}

---

## Prompting

### In-Context Learning: Zero-Shot and Few-Shot

**Concept:**  
In-Context Learning (ICL) refers to the ability of large language models (LLMs) to perform tasks by conditioning on examples provided in the input prompt, without any gradient updates or fine-tuning. This capability emerged prominently with GPT-3, as shown in Brown et al. (2020), *Language Models are Few-Shot Learners*.

Traditionally, models learn behavior during training stages such as pre-training and post-training that involve updating model weights. In contrast, ICL allows a model to learn the desired behavior from the *context* in which the prompt is given, even if the desired task differs from what it was explicitly trained to do. No weight updates are performed; instead, the model leverages its massive training data and generalization ability.

**How It Works**

- The model treats the prompt as a temporary training set, inferring patterns between inputs and outputs.
- These patterns are applied to new examples within the same prompt context.
- This enables the model to adapt its behavior on-the-fly without persistent changes to its parameters.


**Key Variants**

**1. Zero-Shot Prompting:** Ask the model to perform a task using only an instruction or question — without providing any explicit examples of how the task should be done. 
 
  - The model relies solely on its pre-trained knowledge and its understanding of the instruction to produce the output.  
  - Even without examples, the instruction itself acts as a minimal form of *context* that the model conditions on.  
   
  Example: Translate the following sentence into French: The weather is beautiful today.  
  No translations are shown beforehand — the model generates the French sentence using patterns it learned during training.

**2. Few-Shot Prompting:** Provide a small number of (input → output) examples before asking for a new prediction. 
 
  - One example = one “shot” (e.g., 5 examples = 5-shot learning).
  - More examples generally improve performance, but are limited by the model’s maximum context length.

  Example: Showing labeled sentiment examples before asking for classification of a new sentence.  

![**Figure:** Illustration of three In-Context Learning settings — Zero-Shot, One-Shot, and Few-Shot — compared with traditional fine-tuning. In ICL, the model adapts based on examples in the prompt without weight updates, while fine-tuning updates model parameters through repeated training. *(Source: Brown et al., 2020, Language Models are Few-Shot Learners)*](images/eval_strategies.png)  

These prompting strategies differ in how much context the model receives before making a prediction. The charts below reveal how both model size and the number of in-context examples impact benchmark accuracy.

![**Figure:** SuperGLUE performance comparison between zero-shot, one-shot, and few-shot prompting, showing the effect of model size (left) and number of in-context examples (right). (Source: Brown et al., 2020, Language Models are Few-Shot Learners)](images/superglue_analysis.png)

**Left chart:** Larger models consistently improve SuperGLUE scores across all prompting types, with few-shot prompting delivering the largest gains — the jump from the smallest (~0.1B) to the largest (175B) model is over 20 points in few-shot mode. 
**Right chart:** For GPT-3 (175B parameters), zero-shot starts at 68.0, one-shot improves to 69.8, and 8-shot reaches 72.5, matching Fine-Tuned BERT++. At 32-shot, performance climbs to 75.5, surpassing Fine-Tuned BERT++ without any parameter updates.


::: {.callout-tip title="Performance Summary"}
Across all prompting types, performance consistently improves as model size increases. Few-shot prompting delivers the largest gains, with GPT-3 (175B) achieving scores close to fine-tuned models without any parameter updates.
:::

**Advantages**

- **Flexibility:** The model can incorporate new information at inference time, enabling it to respond to queries beyond its original training cut-off date.
- **No Retraining Needed:** Eliminates the need to re-train for minor domain or task changes.
- **Emergent Performance:** Works surprisingly well in very large models (e.g., GPT-3 with 175B parameters) for diverse tasks like translation, reading comprehension, arithmetic, SAT questions, and commonsense reasoning.

**Limitations**

- **Context Length Constraints**: Limited by the model’s maximum input size, restricting the number of examples that can be provided.
- **Performance Sensitivity**: Output quality varies depending on prompt wording, ordering, and example selection.
- **Lack of True Learning**: The model’s weights are not updated; adaptation is temporary and disappears when the context changes.
- **Weak Multi-Step Reasoning**: Struggles with tasks requiring reasoning across multiple logical or arithmetic steps.
- **Limited Interpretability**: Produces final answers without an explicit reasoning trail, making verification and debugging difficult.

::: {.callout-note title="Key Insight"}
ICL effectively turns prompting into a form of *temporary fine-tuning*, where the “training data” exists only within the prompt window. This makes it a powerful method for continual adaptation without persistent retraining.
:::

Some of these reasoning limitations — particularly weak multi-step reasoning — can be addressed with **Chain-of-Thought prompting** (Wei et al., 2022), which guides the model to generate intermediate steps before producing the final answer.


### Addressing ICL’s Reasoning Limitations: Chain-of-Thought Prompting

**Concept:**  
Chain-of-Thought (CoT) prompting is a technique that augments ICL by adding **natural language reasoning steps** between the input and the final output. Instead of going directly from problem → answer, the model is encouraged to generate a sequence of intermediate steps — a “reasoning chain” — before producing its final answer.

**How It Works:**  

- The prompt explicitly demonstrates step-by-step reasoning for a few training examples in the context.  
- The model learns to emulate this reasoning pattern when solving new tasks in the same prompt.  
- The final output is preceded by a textual reasoning trace, making the model’s thought process transparent.

![**Figure:** Comparison of standard prompting and Chain-of-Thought prompting on arithmetic reasoning tasks. CoT provides explicit step-by-step reasoning, enabling the model to correctly solve problems that standard prompting fails. *(Source: Wei et al., 2022)*](images/cot-reasoning.png)


**Why It Helps:**  

CoT prompting addresses several ICL weaknesses:

- **Improved Multi-Step Reasoning:** By breaking down problems into smaller sub-problems, the model performs better on tasks requiring arithmetic computation, symbolic reasoning, and commonsense logic.
- **Interpretability:** Produces intermediate steps that allow humans to verify and debug reasoning.
- **Error Reduction:** Reduces the likelihood of “shortcut” or guess-based answers by forcing the model to articulate the full solution path.

**Empirical Evidence (Wei et al., 2022):**  

The chart below is arranged **by benchmark in rows** (Row 1 = GSM8K, Row 2 = SVAMP, Row 3 = MAWPS) and **by model family in columns** (Column 1 = LaMDA, Column 2 = GPT, Column 3 = PaLM).  

- **On the GSM8K math word problem benchmark** (Row 1), CoT prompting with **GPT-3 175B** improved solve rate from **17.7%** (standard prompting) to **57.1%**, a gain of nearly **40 percentage points**.  
- **On the SVAMP benchmark** (Row 2), CoT prompting with **GPT-3 175B** increased performance from about **44%** to **72%**, surpassing the prior supervised best.  
- **On the MAWPS benchmark** (Row 3), CoT prompting with **PaLM 540B** boosted accuracy from roughly **78%** to **92%**, matching or exceeding the prior supervised best.  

Across all benchmarks and model families (LaMDA, GPT, PaLM), **larger models consistently show greater gains** from CoT prompting, with the blue curves sitting above the black curves, especially at the largest scales.

![**Figure:** Performance comparison between standard prompting and Chain-of-Thought prompting across GSM8K, SVAMP, and MAWPS benchmarks for different model families (LaMDA, GPT, PaLM). CoT delivers large gains, particularly for larger models. *(Source: Wei et al., 2022)*](images/cot-performance.png)

**When It Works Best:**  

- Tasks with compositional structure where intermediate reasoning steps are natural.  
- Models with sufficient scale (CoT’s benefits appear more strongly in models >100B parameters).  
- Prompts that clearly format and separate reasoning from final answers.

**Advantages**

- **Enhanced Multi-Step Reasoning:** Significant gains on benchmarks like GSM8K and MultiArith.
- **Interpretability:** Step-by-step outputs help in auditing and debugging.
- **Prompt-Only Method:** No fine-tuning required; works within ICL framework.
- **Emergent Capability:** Reasoning skills become apparent in large-scale models.

**Limitations**

- **Model Size Dependency:** Large performance gains appear mainly in models >100B parameters; smaller models often produce incoherent chains.
- **Increased Output Length:** More tokens may affect latency and cost.
- **Limited Benefit for Simple Tasks:** Minimal improvement for factual recall or single-step reasoning.
- **Error Propagation:** Early mistakes in reasoning can cascade to incorrect final answers.
- **Hallucinated Logic:** Reasoning may be coherent but factually wrong.

Beyond prompt engineering, another way to boost model performance without changing its weights is through **Test-Time Scaling (TTS)**.  
While both prompting and TTS work without retraining the model, they target *different levers* for improvement:

| Feature | Prompting | Test-Time Scaling (TTS) |
|---------|-----------|-------------------------|
| **When applied** | Before inference | During inference |
| **What changes** | The *input prompt* to guide the model’s output | The *inference process* — computation allocation, search, sampling |
| **Core mechanism** | Better instructions, examples, or formatting | Iterative refinement, search-based decoding, adaptive sampling |
| **Goal** | Steer the model toward a better answer | Improve accuracy/reasoning by giving the model more “thinking” time or attempts |
| **Analogy** | Asking a student a well-phrased question | Giving the student more scratch paper and extra tries |

This distinction is important: **prompting** focuses on *how you ask*, while **TTS** focuses on *how the model thinks and searches for answers once asked*.

---

## Test‑Time Scaling Methods

**Concept:**  
Test-time scaling (TTS) improves a model’s performance and reasoning during inference—without changing its parameters. While prompting guides the model by adjusting the input text, TTS works by giving the model more “thinking time.” It runs extra computations, explores multiple reasoning paths, and often blends the best results from several runs. Unlike pre-training, which teaches the model new skills through large-scale learning, TTS makes smarter use of existing skills by allocating more resources—like iterative refinement, search-based decoding, or adaptive sampling—based on complexity of the task.

TTS can match the performance of a model up to 14× larger on easy to intermediate tasks, while using up to 4× lower compute cost<sup>[1]</sup>. This makes it highly effective when inference budgets are limited or when the base model already has the necessary core competence. However, for tasks requiring fundamentally new capabilities—such as novel reasoning—**pre-training remains superior**, as larger pre-trained models inherently encode deeper reasoning ability.  

In practice, TTS and pre-training are **complementary**: pre-training builds broad, general‑purpose competence, while TTS offers flexible, on‑demand optimization at inference time. Many deployments use a **hybrid approach**, combining a pre-trained base model with TTS to achieve cost‑efficient scaling and adaptability.

**Why It Matters:**

Test-time scaling lets you squeeze more performance out of your current models by simply working them harder at inference. Instead of paying the price (in time, data, and money) to train a larger model, you can unlock competitive or even superior results by exploring multiple reasoning paths and smartly combining answers. This translates into stronger performance, lower costs, and faster innovation—without the need for heavy, expensive upgrades.

**Advantages:**

- Improves performance without retraining or altering model parameters  
- Can match or exceed much larger models on certain tasks at a fraction of the compute cost  
- Flexible allocation of compute based on input complexity  
- Enables on‑demand scaling in resource‑constrained settings  
- Works well as part of a hybrid strategy with pre-training  

**Limitations:**

- Gains are often smaller on tasks requiring novel skills not present in the base model  
- Additional inference compute can increase latency and operational costs  
- Requires effective task‑complexity estimation to allocate resources efficiently  
- May yield diminishing returns if scaling is excessive for a given task  

The diagram below organizes TTS techniques into categories, showing typical integration flows between methods.

![**Figure:** An overview of Test-Time Scaling methods, organized into categories such as parallel scaling, sequential scaling, and search-based methods. Arrows indicate common integration flows—e.g., Chain-of-Thought Prompting feeding into Tree-of-Thoughts for deeper reasoning. This structure helps practitioners select the right combination of strategies based on task complexity. *(Source: Kumar et al., 2023)*](images/test-time-scaling.png)

**Category Overview:**  

- **Scaling Strategies** – Methods that expand search breadth or depth, exploring multiple reasoning paths to increase accuracy (e.g., Beam Search, Monte Carlo Tree Search, Best-of-N Search).  
- **Advanced Sampling** – Techniques that selectively sample outputs based on confidence or external verification to improve efficiency and quality (e.g., Confidence-Based Sampling, Search Against Verifiers).  
- **Improved Reasoning** – Approaches that structure thinking into multi-step processes for complex problem-solving (e.g., Chain-of-Thought Prompting, Tree-of-Thoughts, Self-Consistency Decoding).  
- **Sequential Revision** – Iterative refinement strategies that repeatedly improve answers until they meet quality criteria (e.g., Self-Improvement via Refinements).  


While many approaches exist for test‑time scaling, a few have emerged as especially influential in practical LLM applications. The sections below explore some of these methods in greater detail, including their mechanics, strengths, and trade‑offs.

### Best-of-N Search (Rejection Sampling)

**Concept:**  
Best-of-N (BoN) search enhances model performance at inference by generating *N* candidate outputs (often via sampling) and selecting the one that scores highest according to a chosen criterion — such as a reward model, likelihood score, or rule-based evaluator. This approach systematically explores multiple solution paths and prunes all but the top-rated result. Compared to Beam Search, BoN treats each candidate independently, which can increase diversity but may also be more computationally expensive.  

In reinforcement learning contexts, BoN can be integrated with a learned reward model to pick the best candidate from multiple rollouts, yielding strong performance in reasoning-heavy tasks. It is a popular choice in applications like question answering, code generation, and reasoning benchmarks.

**Advantages:**

- Can significantly boost task performance, especially with a robust reward model
- Flexible — works with both rule-based and learned scoring functions
- Simple to implement; requires only control over *N* and the selection criterion
- Competitive with post-training methods like RLHF and DPO when paired with strong evaluators

**Limitations:**

- Higher computational cost as *N* increases  
- Performance depends heavily on the quality of the scoring function or reward model  
- May select lower-probability solutions if scoring is imperfect (reward hacking risk)  
- Instability can occur if the *N* parameter is too large or too small for the task  


### Self-Consistency Decoding

**Concept:**  
Self-Consistency is a decoding strategy designed to improve reasoning by aggregating answers from multiple reasoning paths. Instead of following a single chain of thought, the model samples diverse reasoning chains (using techniques like prompt engineering to encourage diversity, temperature sampling, or stochastic decoding) and then outputs the final answer that is most consistent across them.  

The underlying intuition is that if a complex question has a unique correct answer, different valid reasoning paths should converge on the same result. This *majority vote* or *highest probability after marginalization* approach reduces the likelihood of errors from flawed single reasoning chains and is especially effective in reasoning tasks.

**Advantages:**

- Improves correctness in complex reasoning scenarios  
- Works well for arithmetic, commonsense reasoning, and multi-step problem-solving  
- Reduces reliance on any single, potentially flawed reasoning path  
- Can be combined with Chain-of-Thought prompting for greater gains

**Limitations:**

- Higher inference cost due to multiple reasoning path generations  
- Gains diminish for simpler tasks where a single reasoning path is sufficient  
- Effectiveness depends on diversity and quality of sampled reasoning paths  


::: callout-note
## Key Difference: Best-of-N vs. Self-Consistency

- **Best-of-N Search (Rejection Sampling):** Goal is to find the *highest-quality* single output.  
  The model is run multiple times with the same prompt, and each output is scored or filtered using a heuristic, probability, or verifier. The output with the best score is selected.

- **Self-Consistency Decoding:** Goal is to find the answer most reasoning paths agree on.  
  The model is run multiple times, encouraging different step-by-step reasoning chains. The final answer from each chain is collected, and the one appearing most often (majority vote) is chosen.

**In short:** Best-of-N picks the *best-rated* answer. Self-Consistency picks the *most common* answer.
:::


The following table summarizes key test‑time scaling methods described in *LLM Post‑Training: A Deep Dive into Reasoning* by Komal Kumar, Tajamul Ashraf et al.

| Method | Goal & Common Use Cases | Benefits | Limitations |
|--------|------------------------|----------|-------------|
| **Beam Search** | Maintain top‑N highest‑probability reasoning paths at each step; used in structured reasoning, planning, and Tree‑of‑Thought search. | Improves coherence and accuracy by systematically exploring multiple reasoning chains. | Computationally expensive; beam width must be tuned; may still miss rare but correct paths. |
| **Best‑of‑N (Rejection Sampling)** | Generate N candidate outputs (via sampling) and select the best using a criterion (e.g., reward model, model likelihood). | Improves answer quality for easier tasks; straightforward to implement; flexible budget. | High cost if N is large; requires effective selection criteria; may miss diversity benefits. |
| **Compute‑Optimal Scaling (COS)** | Dynamically allocate compute based on task difficulty; use more search for hard cases, less for easy ones. | Balances accuracy and efficiency; can achieve large efficiency gains over uniform sampling. | Requires reliable difficulty estimation; complex to implement in production. |
| **Self‑Consistency Decoding** | Sample multiple reasoning chains, then select the most common final answer. | Improves multi‑step reasoning accuracy; simple and model‑agnostic. | Higher inference cost; relies on majority vote, which may fail if most outputs are wrong. |
| **Tree of Thoughts (ToT)** | Expand multiple reasoning paths as a search tree, evaluating and pruning branches. | Enhances complex problem solving and planning; allows backtracking. | High computational cost; requires good heuristics to prune effectively. |
| **Graph of Thoughts (GoT)** | Represent reasoning steps as a graph with flexible dependencies; enables merging and dynamic exploration. | More adaptable than ToT; reduces redundant computation; efficient for complex reasoning. | Implementation complexity; less studied than ToT. |
| **Confidence‑Based Sampling** | Select expansions or answers based on model confidence scores. | Reduces wasted exploration on low‑probability paths; can improve efficiency. | Confidence scores may not correlate with correctness; risk of overconfidence. |
| **Search‑Augmented Verification** | Use external verifiers to evaluate and rank candidate answers or reasoning steps. | Increases correctness in binary decision tasks; modular and flexible. | Dependent on verifier quality; additional inference steps add latency. |
| **Self‑Improvement via Refinements** | Model iteratively critiques and revises its own answers until acceptable. | Can improve accuracy across varied tasks; useful for open‑ended reasoning. | Risk of over‑editing or drifting from initial intent; higher inference cost. |
| **Monte Carlo Tree Search (MCTS)** | Explore possible reasoning paths via random simulations, guided by heuristics and rewards. | Effective for planning and reasoning under uncertainty; supports large search spaces. | High computational cost; requires effective reward design. |
| **Chain‑of‑Action‑Thought Reasoning** | Integrate action planning with reasoning steps for complex tasks. | Handles multi‑agent, tool‑augmented reasoning; improves adaptability. | Complex to implement; requires specialized training or prompting. |

While prompting and test-time scaling adjust model behavior without altering weights, supervised fine-tuning directly updates model parameters to improve performance on specific tasks.

---

## Supervised Fine-Tuning (SFT)

**Concept:**  

Supervised Fine-Tuning (SFT) is a post-training method where a pre-trained foundation model is further trained on labeled examples (input–output pairs) to better align it with desired behaviors or domain needs. While pre-training learns broad language patterns, SFT narrows the focus—adapting the model for specific goals by adjusting its internal weights on high-quality datasets. In contrast to prompting or test-time scaling, which only influence outputs at inference time, SFT changes the model’s parameters directly, so the improvements stay in the model even after the training.


SFT can be applied in two main ways:  

- **General-purpose instruction tuning** – teaching the model to follow diverse natural language instructions across many tasks.  
- **Domain-specific tuning** – adapting the model for specialized fields such as legal, medical, or financial applications.  

**Why it matters:**  

SFT is one of the most effective ways to improve task performance, consistency, and controllability in large language models. It also serves as the foundation for later optimization steps such as preference alignment (e.g., RLHF or DPO).
 
While many approaches exist for supervised fine‑tuning, **Instruction Fine‑Tuning** and **Domain‑Specific Fine‑Tuning** are among the most prevalent in modern LLM post‑training pipelines. The sections below explore these methods in greater detail.


### Instruction Fine-Tuning

**Concept:**  

Instruction Fine-Tuning is the most common form of SFT, focusing on training a pre-trained model with a broad range of instruction–response examples across tasks like summarization, question answering, classification, and creative writing. The aim is to help the model reliably follow natural language instructions — even for tasks it hasn’t explicitly seen — by aligning outputs with the user’s intent rather than simply predicting the next word. 

**Advantages:** 
 
- Strong generalization to unseen tasks in zero-shot and few-shot settings.
- Produces more helpful, consistent, and structured outputs.
- Improves controllability across varied prompt styles.
- Provides a solid baseline for later optimization.

**Limitations:**  

- Needs large, diverse, and high-quality instruction datasets.
- Open-ended tasks can be hard to evaluate objectively.
- Human-generated data may bring bias, inconsistency, or noise.
- Risk of overfitting to the style of the fine-tuning dataset if it lacks diversity.


The table below reports results from the **Flan (Wei et al., 2022)** study, which evaluated the impact of supervised fine-tuning (SFT) — specifically *instruction fine-tuning* — on multiple pre-trained language models of different sizes (ranging from 80M to 540B parameters). 

Performance is measured across four benchmarks:  

- **MMLU** – a multi-task test covering 57 diverse subjects.  
- **BBH** – the Big-Bench Hard set of reasoning tasks.  
- **TyDiQA** – a multilingual question-answering benchmark.  
- **MGSM** – multilingual grade school math problems.  

The “Norm. avg.” column is the unweighted normalized average score across all benchmarks, while “Direct” and “CoT” show performance under direct prompting and chain-of-thought prompting. Gains in parentheses represent improvement in normalized average from adding SFT.  

![**Figure:** Performance of instruction-fine-tuned models (FLAN, FLAN-PaLM) compared to their base models on a mix of unseen task categories. Results show consistent improvements across model sizes, with gains of up to 9–10 points in average accuracy after instruction fine-tuning. *(Source: Wei et al., 2022, “Fine-tuned Language Models are Zero-Shot Learners”)*](images/flan_performance_table.png)

Instruction fine-tuning consistently improves performance across model sizes. In the Flan-T5 family, gains tend to grow with model size — from +6.1 for the 80M model to +26.6 for the 11B model. For PaLM, the 62B version’s normalized average jumps from 28.4 to 38.8 (+10.4), with notable gains on MMLU (55.1 → 59.6) and MGSM (18.2 → 28.5). The largest 540B model also improves from 49.1 to 58.4 (+9.3) and boosts TyDiQA accuracy from 52.9 to 67.8. While the improvement is smaller in absolute terms for the 540B model, this is because it starts from a much higher baseline, leaving less headroom for improvement<sup>[5]</sup>.

### Domain-Specific Fine-Tuning

**Concept:**  

Domain-Specific Fine-Tuning narrows the model’s focus to excel in a specialized area — such as finance, healthcare, law, climate science, or software engineering — by training it on carefully selected domain-relevant datasets. This targeted approach strengthens the model’s command of the terminology, style, and knowledge specific to the field, enabling more precise, trustworthy, and context-aware outputs for professional or high-stakes use.

**Advantages:**  

- Boosts accuracy, factual grounding, and relevance in the chosen domain.
- Builds user trust in sensitive or regulated applications.
- Supports compliance with industry standards.
- Can reduce hallucinations by anchoring responses in vetted domain content.

**Limitations:**  

- Requires high-quality domain datasets, which may be expensive or hard to source.
- May lose versatility on out-of-domain tasks.
- Inherits biases or blind spots from domain data.
- Risk of over-specialization if coverage is too narrow.


The chart below reports results from the *BioMedLM* study (Singhal et al., 2022), which applied **domain-specific fine-tuning** to a large pre-trained model (Flan-PaLM 540B) using biomedical and clinical datasets from the MultiMedQA benchmark. Performance is compared against the best previously published models across three key datasets:  

- **MedMCQA** – general medical knowledge in Indian medical entrance exams.  
- **MedQA (USMLE)** – general medical knowledge in US medical licensing exams.  
- **PubMedQA** – biomedical literature question answering.  

Accuracy (%) is shown for the previous state-of-the-art (SOTA) and for the domain-tuned Flan-PaLM 540B model.  

![**Figure:** Accuracy of Flan-PaLM 540B after domain-specific fine-tuning compared to previous state-of-the-art models on three biomedical QA benchmarks. *(Source: Singhal et al., 2022, “Large Language Models Encode Clinical Knowledge”)*  ](images/domain_specific_performance.png)  

Domain-specific fine-tuning delivers **substantial accuracy gains** across all three benchmarks. On **MedQA (USMLE)**, Flan-PaLM 540B achieves **67.6%**, exceeding the previous best (PubMedGPT) by over **17 points**. On **MedMCQA**, performance rises to **57.6%** from the prior best of **52.9%**, while on **PubMedQA** it reaches **79.0%**, slightly surpassing the earlier record of **78.2%**. These results demonstrate that aligning a large language model with specialized biomedical knowledge can yield meaningful improvements, especially for complex, domain-specific reasoning tasks, even when starting from an already strong general-purpose model<sup>[6]</sup>.



The following table summarizes supervised fine-tuning methods described in *LLM Post-Training: A Deep Dive into Reasoning* by Komal Kumar, Tajamul Ashraf et al.

| Fine-tuning Type | Goal & Common Use Cases | Benefits | Limitations |
|-----------------|------------------------|----------|-------------|
| **Instruction Fine-Tuning** | Train LLMs to follow diverse instructions (e.g., summarization, classification, QA, creative writing). Enables zero-/few-shot generalization across tasks. | Improves generalization and alignment; makes outputs more helpful and controllable. | Requires large, curated datasets; open-ended tasks are harder to evaluate; may reflect human bias. |
| **Dialogue (Multi-turn) Fine-Tuning** | Enable coherent, context-aware multi-turn conversations for chatbots and digital assistants. | Improves coherence, context tracking, and conversational experience. | Can overfit to chattiness; needs large, high-quality multi-turn dialogue datasets. |
| **Chain-of-Thought (CoT) Reasoning Fine-Tuning** | Encourage step-by-step reasoning in math, logic puzzles, multi-hop QA. | Improves reasoning interpretability and multi-step accuracy. | Requires structured reasoning traces; limited to reasoning-style tasks. |
| **Domain-Specific Fine-Tuning** | Adapt models for specialized fields (e.g., biomedicine, finance, legal, climate, code). | Improves accuracy and relevance in domain-specific applications. | Needs high-quality, domain-specific corpora; risk of reduced generality. |
| **Distillation-Based Fine-Tuning** | Transfer capabilities from a large “teacher” model to a smaller “student” model. | Produces smaller, faster models with high performance; reduces compute cost. | May lose nuance or performance compared to teacher; quality depends on teacher data. |
| **Preference/Alignment SFT** | Train models on labeled or ranked preference data before RLHF or DPO stages. | Improves alignment with human values; reduces harmful or irrelevant outputs. | Limited by scope and quality of preference data; definitions of “desirable” can vary. |
| **Parameter-Efficient Fine-Tuning (PEFT)** | Efficiently adapt models without updating all weights (e.g., LoRA, adapters, prefix tuning). | Resource-efficient; enables adaptation on limited hardware. | May underperform full fine-tuning; sensitive to hyperparameter choices. |

Once the model has been trained to follow instructions, the next step is often to align it more closely with human preferences through preference optimization.


## Preference Optimization

**Concept:**  

Preference optimization is the process of aligning a model’s outputs with human preferences using feedback signals, rather than solely optimizing for task performance. In large language models (LLMs), this often involves training the model to produce responses that are not only factually correct but also safe, contextually relevant, and consistent with user expectations.  
Unlike conventional reinforcement learning, which operates in small, well‑defined action spaces with clear objectives, preference optimization in LLMs must navigate a **vast vocabulary action space**, delayed and subjective rewards, and multiple, sometimes conflicting, objectives. Feedback is often based on human or AI‑generated preference comparisons and can involve both outcome‑based metrics (e.g., correctness) and process‑based evaluations (e.g., reasoning quality).  
The overarching goal is to make models behave according to human preferences — an ambitious aim given that universal human values do not exist, and perceptions of “desirable” behavior vary widely across cultures, political views, and personal beliefs.

**Advantages:**  

- Aligns model outputs with user expectations and ethical guidelines.  
- Improves perceived helpfulness and safety in real‑world use.  
- Can reduce harmful, offensive, or irrelevant outputs.  
- Allows optimization for nuanced objectives (e.g., tone, reasoning quality, factuality).  
- Supports personalization to match specific user or organizational preferences.

**Limitations:**  

- Subjectivity of preferences — what’s “helpful” or “appropriate” can vary across cultures, contexts, and individuals.  
- Controversial topics — responses risk alienating some users regardless of stance; overly cautious models may seem bland or evasive.  
- Technical complexity — high‑dimensional action space, delayed rewards, and balancing multiple objectives make optimization challenging.  
- Bias and fairness risks — preferences used in training may embed societal biases.  
- Deployment trade‑offs — excessive filtering can reduce engagement, while insufficient filtering can create reputational and safety risks.  

While many approaches exist for preference optimization, **Reinforcement Learning from Human Feedback (RLHF)** and **Direct Preference Optimization (DPO)** are two of the most prominent in modern LLM alignment pipelines. The sections below explore these methods in greater detail.


### Reinforcement Learning from Human Feedback (RLHF)

**Concept:**  
RLHF aligns LLMs with human preferences by collecting feedback from human annotators and using it to guide reinforcement learning. The process typically involves:  
1. Supervised Fine‑Tuning (SFT) on high‑quality instruction‑response pairs to create a baseline model.  
2. Preference data collection — human annotators rank multiple model outputs for the same prompt.  
3. Reward model training — a separate model learns to predict these rankings.  
4. Reinforcement learning optimization — the LLM is fine‑tuned using algorithms like PPO to maximize the reward model score while staying close to the baseline model.

**Advantages:**  

- Produces highly aligned and safe responses.  
- Can optimize for complex, nuanced objectives beyond accuracy.  
- Allows fine‑grained control through reward model design.

**Limitations:** 
 
- Very expensive and labor‑intensive to gather preference data.  
- Quality depends heavily on the consistency and skill of annotators.  
- Reward models can be exploited (reward hacking).  
- Sensitive to bias in the collected preferences.


### Direct Preference Optimization (DPO)

**Concept:**  
DPO is a simpler alternative to RLHF that removes the need for a separate reward model and online reinforcement learning. Instead of predicting absolute reward scores, DPO learns directly from preference pairs (chosen vs. rejected outputs) by optimizing the log‑likelihood ratio to make preferred responses more probable. This approach “bakes in” the user’s preferences directly into the model parameters, avoiding the complexity of the RL loop.

**Advantages:**  

- Simpler and more stable than RLHF.  
- No need for online sampling or PPO training.  
- Scales well to large datasets.  
- Increasingly popular in open‑source models like LLaMA and OpenChat.

**Limitations:**  

- No per‑step credit assignment — treats whole responses as a unit.  
- May underperform RLHF for multi‑step reasoning tasks.  
- Dependent on high‑quality preference pairs; poor data reduces effectiveness.


The following table summarizes supervised Preference Optimization methods described in *LLM Post-Training: A Deep Dive into Reasoning* by Komal Kumar, Tajamul Ashraf et al.

| Method | Goal & Common Use Cases | Benefits | Limitations |
|--------|------------------------|----------|-------------|
| **RLHF (Reinforcement Learning from Human Feedback)** | Align model outputs with human expectations using preference comparisons from human annotators to train a reward model, then optimize with RL (e.g., PPO). | Produces helpful, safe, and human-aligned responses; can optimize for nuanced objectives; widely adopted in practice. | Expensive and time‑consuming to collect human preference data; reward models can be overfit or gamed; dependent on noisy human judgments. |
| **RLAIF (Reinforcement Learning from AI Feedback)** | Replace human annotation with AI‑generated feedback to create preference labels for training the reward model. | Reduces cost and time; scalable to large datasets; avoids bottleneck of human labeling. | Quality depends on feedback model; risk of propagating biases or errors from the AI judge; less diversity than human feedback. |
| **DPO (Direct Preference Optimization)** | Learn directly from preference pairs without training a separate reward model or running PPO, by optimizing likelihood ratios to favor preferred responses. | Simpler and more stable than RLHF; no online sampling; scalable; increasingly popular in open‑source LLMs. | Lacks per‑step credit assignment; may underperform RLHF for complex reasoning tasks; dependent on high‑quality preference data. |
| **OREO (Online Reasoning Optimization)** | RL method to improve multi‑step reasoning by refining policies based on reasoning‑step evaluations rather than just final answers. | Fine‑grained feedback at reasoning step level; boosts reasoning accuracy and interpretability. | Computationally intensive; domain‑specific; requires curated reasoning traces. |
| **GRPO (Group Relative Policy Optimization)** | RL variant that scores multiple outputs for the same query relative to each other, eliminating the need for a critic model. | Reduces memory usage; stabilizes training; enables fine‑grained rewards for complex reasoning tasks. | Requires large groups of candidate responses; effectiveness depends on diversity and quality of generated outputs. |
| **Pure RL‑Based LLM Refinement** | Multi‑stage RL pipelines (e.g., DeepSeek-R1) that refine models without or with minimal SFT, often incorporating distillation and curated reasoning traces. | Can achieve high performance without large SFT datasets; distillation improves efficiency; robust reasoning capabilities. | Complex to implement; computationally expensive; requires large curated datasets for stability and quality. |



## Conclusion

Post‑training for foundation models is not a single method, but a toolbox of strategies that work best in combination. Prompting and test‑time scaling methods can produce immediate gains without changing model weights, making them ideal for rapid experimentation and deployment. Supervised fine‑tuning adapts models for broad instruction‑following or specialized domains, while preference optimization aligns model behavior with human values and expectations.

In practice, high‑performing LLM systems often blend these techniques: using prompting for quick control, test‑time scaling for reasoning‑heavy queries, supervised fine‑tuning for skill building, and preference optimization for safety and alignment. As the field evolves, we can expect tighter integration between these approaches, along with emerging trends like agentic AI, retrieval‑augmented generation, and continuous self‑improvement loops.

The key takeaway: effective post‑training is about matching the method to the goal. Understanding the trade‑offs of each category enables practitioners to build LLM solutions that are not only more capable, but also safer, more reliable, and better aligned with human intent.


## References & Further Reading

[1] Kumar, K., Ashraf, T., Thawakar, O., et al. (2024). *LLM Post-Training: A Deep Dive into Reasoning Large Language Models*. https://arxiv.org/abs/2502.21321 

[2] Brown, T., Mann, B., Ryder, N., et al. (2020). *Language Models are Few-Shot Learners (GPT-3)*. https://arxiv.org/abs/2005.14165 

[3] Wei, J., Wang, X., Schuurmans, D., et al. (2022). *Chain-of-Thought Prompting Elicits Reasoning in Large Language Models*. https://arxiv.org/abs/2201.11903  

[4] Ouyang, L., Wu, J., Jiang, X., et al. (2022). *Training Language Models to Follow Instructions with Human Feedback (InstructGPT)*. https://arxiv.org/abs/2203.02155  

[5] Chung, H. W., Hou, L., Longpre, S., et al. (2022). *Scaling Instruction-Finetuned Language Models (Flan)*. https://arxiv.org/abs/2210.11416  

[6] Singhal, K., Azizi, S., Tu, T., et al. (2022). *Large Language Models Encode Clinical Knowledge*. https://arxiv.org/abs/2212.13138

[7] Rafailov, R., Sharma, A., Mitchell, E., et al. (2023). *Direct Preference Optimization: Your Language Model is Secretly a Reward Model*. https://arxiv.org/abs/2305.18290  

[8] Wei, J., Wang, X., Schuurmans, D., et al. (2022). *Chain-of-Thought Prompting Elicits Reasoning in Large Language Models*. https://arxiv.org/abs/2201.11903  

[9] Wang, X., Wei, J., Schuurmans, D., et al. (2022). *Self-Consistency Improves Chain of Thought Reasoning in Language Models*. https://arxiv.org/abs/2203.11171  

[10] Yao, S., Yu, D., Zhao, J., et al. (2023). *Tree of Thoughts: Deliberate Problem Solving with Large Language Models*. https://arxiv.org/abs/2305.10601  

[11] Houlsby, N., Giurgiu, A., Jastrzebski, S., et al. (2019). *Parameter-Efficient Transfer Learning for NLP*. https://arxiv.org/abs/1902.00751 

[12] Radford, A., Wu, J., Child, R., et al. (2019). *Language Models are Unsupervised Multitask Learners*. https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf  

[13] Kojima, T., Gu, S. S., Reid, M., et al. (2022). *Large Language Models are Zero-Shot Reasoners*. https://arxiv.org/abs/2205.11916  

[14] Zhou, X., Santurkar, S., Bau, D., et al. (2022). *Large Language Models Are Human-Level Prompt Engineers*. https://arxiv.org/abs/2211.01910  

[15] Huyen, C. (2024). *AI Engineering: Building Applications with Foundation Models*. O’Reilly Media.  

[16] Alammar, J., & Grootendorst, M. (2023). *Hands-On Large Language Models: Language Understanding and Generation*. O’Reilly Media. 


 