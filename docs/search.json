[
  {
    "objectID": "gen-ai-use-cases/banking-use-cases.html",
    "href": "gen-ai-use-cases/banking-use-cases.html",
    "title": "Generative AI Use Cases in Banking",
    "section": "",
    "text": "Generative AI is redefining how banks operate ‚Äî from automating customer service to streamlining underwriting. Below are practical examples showing how leading financial institutions are applying GenAI for real business value."
  },
  {
    "objectID": "gen-ai-use-cases/banking-use-cases.html#summary-of-use-cases",
    "href": "gen-ai-use-cases/banking-use-cases.html#summary-of-use-cases",
    "title": "Generative AI Use Cases in Banking",
    "section": "1 üìã Summary of Use Cases",
    "text": "1 üìã Summary of Use Cases\n\n\n\n\n\n\n\n\nUse Case Area\nExamples\nBenefits\n\n\n\n\nCustomer Engagement\nErica, Cora+, Fargo, Eliza\n24/7 support, lower call volume\n\n\nOperational Efficiency\nLLM Suite, AskResearchGPT, PwC\nProcess streamlining, reduced manual work\n\n\nRisk Management\nMastercard DI, Wells Fargo Fraud\nEarly fraud detection, loss prevention\n\n\nCredit Underwriting\nCreditLens, COiN Platform\nQuicker approvals, lower compliance risk\n\n\nPersonalized Marketing\nJPMorgan Campaigns\nBetter targeting, higher engagement\n\n\nGenerative BI\nCopilot, ThoughtSpot, Custom Assistants\nSelf-service insights, exec summaries"
  },
  {
    "objectID": "gen-ai-use-cases/banking-use-cases.html#use-cases-in-banking",
    "href": "gen-ai-use-cases/banking-use-cases.html#use-cases-in-banking",
    "title": "Generative AI Use Cases in Banking",
    "section": "2 Use Cases in Banking",
    "text": "2 Use Cases in Banking\n\n2.1 üè¶ Customer Engagement\n\n\n\n\n\n\nWhy it matters:\nGenerative AI enables banks to deliver faster, more intelligent, and more personalized customer service. By automating routine interactions and offering real-time assistance, banks can improve customer satisfaction, reduce support costs, and scale their service capabilities without increasing headcount.\n\n\n\nExamples:\n- Bank of America ‚Äì Erica: Offers financial guidance through natural language interactions, helping users with budgeting, transactions, and account management.\n- NatWest ‚Äì Cora+: Anticipates customer needs and provides proactive responses using conversational AI.\n- Wells Fargo ‚Äì Fargo: Supports English and Spanish to help customers manage cards and access banking services via natural language.\n- BNY Mellon ‚Äì Eliza: Internal chatbot and tooling platform used by 52,000 employees to build GenAI-powered apps like lead generation tools.\n\n\n2.2 üìä Operational Efficiency\n\n\n\n\n\n\nWhy it matters:\nBanks deal with vast volumes of reports, compliance documentation, and internal knowledge. Generative AI improves productivity by summarizing documents, automating workflows, and assisting developers ‚Äî freeing employees to focus on higher-value tasks and accelerating project delivery.\n\n\n\nExamples:\n- JPMorgan ‚Äì LLM Suite: Automates document summarization, content creation, and reporting.\n- Morgan Stanley ‚Äì AskResearchGPT: Provides natural language access to 70,000+ research reports.\n- PwC ‚Äì Compliance Automation: Uses GenAI to summarize regulatory documents and extract clauses.\n- Citi ‚Äì Reporting Automation: Streamlines compliance reporting and data extraction.\n- Standard Chartered ‚Äì SC GPT: SC GPT helps employees retrieve information faster, and summarize internal documents. - Citigroup ‚Äì AI Tools for Developers: Boosts engineering productivity with GenAI code assistance.\n\n\n2.3 üîê Risk Management\n\n\n\n\n\n\nWhy it matters:\nFraud detection and risk modeling are core to banking safety. GenAI enhances traditional models by spotting subtle anomalies, synthesizing potential fraud scenarios, and enabling faster investigation of suspicious transactions.\n\n\n\nExamples:\n- Mastercard ‚Äì Decision Intelligence: Evaluates over 1 trillion data points in real time to approve 143+ billion transactions annually.\n- Wells Fargo ‚Äì AI for Fraud: Uses GenAI for enhanced anomaly detection in transactional data.\n\n\n2.4 üìù Credit Approval and Loan Underwriting\n\n\n\n\n\n\nWhy it matters:\nCredit underwriting involves reviewing complex financial documents and assessing risk within tight timeframes. Generative AI helps automate the analysis of financial statements, legal documents, and industry benchmarks, enabling faster loan decisions, improved accuracy, and streamlined compliance.\n\n\n\nExamples:\n- Moody‚Äôs Analytics ‚Äì CreditLens: Automates credit memo creation and industry analysis with generative tools.\n- JPMorgan Chase ‚Äì COiN Platform: Uses GenAI to analyze legal contracts in seconds, reducing loan underwriting time.\n\n\n2.5 üì£ Personalized Marketing\n\n\n\n\n\n\nWhy it matters:\nGenerative AI enables banks to move beyond mass marketing and deliver personalized, data-driven messaging. This improves customer engagement, increases conversion rates, and enhances long-term loyalty.\n\n\n\nExamples:\n- JPMorgan Chase ‚Äì Hyper-personalized Campaigns: Uses GenAI to create individualized marketing materials.\n\n\n2.6 üìà Generative Business Intelligence (Gen BI)\n\n\n\n\n\n\nWhy it matters:\nGenerative BI transforms data consumption by allowing non-technical users to explore reports, uncover insights, and ask ad hoc questions using natural language ‚Äî all without waiting on analysts. This boosts data literacy and speeds up decision-making across business units.\n\n\n\nExamples:\n- Microsoft Copilot in Power BI: Enables users to ask natural-language questions and instantly generate charts or summaries.\n- ThoughtSpot Sage: Combines search with GenAI to explain patterns and alert users to anomalies.\n- Internal Gen BI tools: Many banks are building custom assistants on top of Snowflake, BigQuery, or Lakehouse environments to support executive dashboards and ops reviews."
  },
  {
    "objectID": "gen-ai-use-cases/banking-use-cases.html#key-takeaways",
    "href": "gen-ai-use-cases/banking-use-cases.html#key-takeaways",
    "title": "Generative AI Use Cases in Banking",
    "section": "3 üßæ Key Takeaways",
    "text": "3 üßæ Key Takeaways\n\nGenAI is no longer experimental in banking ‚Äî it‚Äôs powering real customer-facing and internal systems.\nUse cases like customer engagement, underwriting, and Gen BI deliver measurable productivity and experience gains.\nAs the industry matures, GenAI will likely integrate deeper into core banking platforms and regulatory processes."
  },
  {
    "objectID": "gen-ai-use-cases/banking-use-cases.html#references",
    "href": "gen-ai-use-cases/banking-use-cases.html#references",
    "title": "Generative AI Use Cases in Banking",
    "section": "4 üìö References",
    "text": "4 üìö References\n[1] Bank of America. (2024). Erica: Virtual Financial Assistant. https://info.bankofamerica.com/en/digital-banking/erica\n[2] NatWest Group. (2024). NatWest launches Cora+. https://www.natwestgroup.com/news-and-insights/news-room/press-releases/data-and-technology/2024/jun/natwest-launches-cora-plus-the-latest-generative-ai-upgrade-to-t.html\n[3] Wells Fargo. (2024). Meet Fargo: AI-powered banking assistant. https://sites.wf.com/fargo/\n[4] Wall Street Journal. (2024). BNY signs multiyear deal with OpenAI. https://www.wsj.com/articles/bny-americas-oldest-bank-signs-multiyear-deal-with-openai-74987d1d\n[5] Morgan Stanley. (2024). AI at Morgan Stanley Debrief launch. https://www.morganstanley.com/press-releases/ai-at-morgan-stanley-debrief-launch\n[6] Wall Street Journal. (2024). Inside OpenAI‚Äôs deal with BBVA. https://www.wsj.com/articles/six-months-thousands-of-gpts-and-some-big-unknowns-inside-openais-deal-with-bbva-5d6f1c03\n[7] JPMorgan Chase. (2024). Deploying ChatGPT-like Assistant. https://www.cnbc.com/2024/08/09/jpmorgan-chase-ai-artificial-intelligence-assistant-chatgpt-openai.html\n[8] Morgan Stanley. (2024). Announces AskResearchGPT. https://www.morganstanley.com/press-releases/morgan-stanley-research-announces-askresearchgpt\n[9] PwC. (2023). Building trust in AI for tax compliance. https://www.pwc.com/gx/en/services/tax/connected-tax-compliance/build-trust-ai-tax-compliance.html\n[10] Citigroup. (2019). Citi Global Trade uses AI to digitize compliance in next-generational project. https://www.citigroup.com/global/news/press-release/2019/citi-global-trade-uses-ai-to-digitie-compliance-in-next-generational-project\n[11] Citi Ventures. (2024). Investing in Poolside. https://www.citi.com/ventures/perspectives/pressrelease/investing-in-poolside.html\n[12] Mastercard. (2024, February). Mastercard supercharges consumer protection with Gen AI. https://www.mastercard.com/news/press/2024/february/mastercard-supercharges-consumer-protection-with-gen-ai/\n[13] Wells Fargo Stories. (2024). How AI could reshape banking. https://stories.wf.com/artificial-intelligence-has-the-potential-to-reshape-banking/\n[14] Moody‚Äôs Analytics. (2024). Revolutionizing loan origination with GenAI. https://www.moodys.com/web/en/us/insights/lending/revolutionizing-loan-origination-with-genai.html\n[15] Futurism. (2024). AI completed 360,000 hours of finance work in just seconds. https://futurism.com/an-ai-completed-360000-hours-of-finance-work-in-just-seconds\n[16] CTO Magazine. (2024). JP Morgan Chase accelerates AI adoption. https://ctomagazine.com/jp-morgan-chase-accelerates-ai-adoption/\n[17] Standard Chartered. (2024). Standard Chartered Rolls Out SC GPT, Advancing AI-Driven Innovation in Banking. Retrieved from https://www.sc.com/en/press-release/standard-chartered-rolls-out-sc-gpt-advancing-ai-driven-innovation-in-banking/\n[18] Standard Chartered. (2024). The Disruptive Potential of Generative AI. Retrieved from https://www.sc.com/en/overlay/the-disruptive-potential-of-generative-ai/"
  },
  {
    "objectID": "ebm.html",
    "href": "ebm.html",
    "title": "Energy Based Models (EBM)",
    "section": "",
    "text": "Modern generative models impose strict architectural requirements:\n\nVAEs need encoder-decoder pairs\n\nGANs require adversarial networks\n\nNormalizing flows must use invertible transforms\n\nWhile each model family has strengths, they also carry trade-offs:\n\nVAEs often produce blurry samples due to reliance on Gaussian assumptions.\n\nGANs can generate high-quality images but are notoriously unstable and suffer from mode collapse.\n\nNormalizing Flows guarantee exact likelihoods but restrict architecture design due to invertibility constraints.\n\n\nEnergy-Based Models (EBMs) break this pattern by:\n\nLearning a scoring function (energy) where it assigns low energy to likely or observed data (\\(x \\sim p_{data}\\)), and high energy to unlikely or unobserved inputs.\nLinking to probability via: \\(p_\\theta(x) = \\frac{e^{-E_\\theta(x)}}{Z(\\theta)}, \\quad Z(\\theta) = \\int e^{-E_\\theta(x)}\\,dx\\)\nwhere low energy = high probability\nUsing generic neural nets‚Äîno specialized architectures needed\n\nThis approach provides unique advantages:\n‚úì Simpler setup - works with any neural net\n‚úì Explicit scoring - \\(p(x) \\propto e^{-E(x)}\\) (energy)\n‚úì Stable training - No adversarial balancing act like GANs\n\n\n\n\n\n\nCore Principle\n\n\n\nEBMs replace architectural constraints with a single principle:\n‚ÄúLearn to distinguish real data from noise through energy scoring.‚Äù\n\n\nTo understand how this works mathematically, we must first answer: What defines a valid probability distribution?\nThe next section derives EBMs‚Äô theoretical foundation‚Äîrevealing how they bypass traditional limitations while introducing new challenges (like partition function estimation)."
  },
  {
    "objectID": "ebm.html#introduction",
    "href": "ebm.html#introduction",
    "title": "Energy Based Models (EBM)",
    "section": "",
    "text": "Modern generative models impose strict architectural requirements:\n\nVAEs need encoder-decoder pairs\n\nGANs require adversarial networks\n\nNormalizing flows must use invertible transforms\n\nWhile each model family has strengths, they also carry trade-offs:\n\nVAEs often produce blurry samples due to reliance on Gaussian assumptions.\n\nGANs can generate high-quality images but are notoriously unstable and suffer from mode collapse.\n\nNormalizing Flows guarantee exact likelihoods but restrict architecture design due to invertibility constraints.\n\n\nEnergy-Based Models (EBMs) break this pattern by:\n\nLearning a scoring function (energy) where it assigns low energy to likely or observed data (\\(x \\sim p_{data}\\)), and high energy to unlikely or unobserved inputs.\nLinking to probability via: \\(p_\\theta(x) = \\frac{e^{-E_\\theta(x)}}{Z(\\theta)}, \\quad Z(\\theta) = \\int e^{-E_\\theta(x)}\\,dx\\)\nwhere low energy = high probability\nUsing generic neural nets‚Äîno specialized architectures needed\n\nThis approach provides unique advantages:\n‚úì Simpler setup - works with any neural net\n‚úì Explicit scoring - \\(p(x) \\propto e^{-E(x)}\\) (energy)\n‚úì Stable training - No adversarial balancing act like GANs\n\n\n\n\n\n\nCore Principle\n\n\n\nEBMs replace architectural constraints with a single principle:\n‚ÄúLearn to distinguish real data from noise through energy scoring.‚Äù\n\n\nTo understand how this works mathematically, we must first answer: What defines a valid probability distribution?\nThe next section derives EBMs‚Äô theoretical foundation‚Äîrevealing how they bypass traditional limitations while introducing new challenges (like partition function estimation)."
  },
  {
    "objectID": "ebm.html#math-review",
    "href": "ebm.html#math-review",
    "title": "Energy Based Models (EBM)",
    "section": "2 Math Review",
    "text": "2 Math Review\n\n2.1 Understanding the Probability Foundation Behind EBMs\nIn generative modeling, a valid probability distribution \\(p(x)\\) must satisfy:\n\nNon-negativity:\n\\[\np(x) \\geq 0\n\\]\nNormalization:\n\\[\n\\int p(x)\\, dx = 1\n\\]\n\nWhile it‚Äôs easy to define a function that satisfies \\(p(x) \\geq 0\\) (e.g., using exponentials), ensuring that it also sums to 1 ‚Äî i.e., \\(\\int p(x)\\, dx = 1\\) ‚Äî is much more difficult, especially for flexible functions like neural networks.\n\n\n\n2.2 Why do we introduce \\(g(x)\\)?\nInstead of modeling \\(p(x)\\) directly, we define a non-negative function \\(g(x) \\geq 0\\) and turn it into a probability distribution by normalizing:\n\\[\np_\\theta(x) = \\frac{g_\\theta(x)}{Z(\\theta)}, \\quad \\text{where} \\quad Z(\\theta) = \\int g_\\theta(x)\\, dx\n\\]\nThis trick simplifies the problem by separating the two requirements:\n\n\\(g_\\theta(x)\\) ensures non-negativity\n\n\\(Z(\\theta)\\) enforces normalization\n\nThe normalization constant \\(Z(\\theta)\\) is also known as the partition function.\nThis trick allows us to use any expressive function for \\(g_\\theta(x)\\) ‚Äî including deep neural networks.\n\n\n2.2.1 Intuition\nThink of \\(g_\\theta(x)\\) as a scoring function:\n\nHigher \\(g_\\theta(x)\\) means more likely\n\nDividing by \\(Z(\\theta)\\) rescales these scores to form a valid probability distribution\n\n\n\n\n\n2.3 Energy-Based Parameterization\nWe‚Äôve just seen how \\(g_\\theta(x)\\) can be any non-negative function. A common and powerful choice is to define it using an exponential transformation:\n\\[\ng_\\theta(x) = \\exp(f_\\theta(x))\n\\]\nThis ensures that \\(g_\\theta(x) \\geq 0\\) and allows us to interpret \\(f_\\theta(x)\\) as an unnormalized log-probability score.\nWe then normalize using the partition function ( Z() ) to obtain a valid probability distribution:\n\\[\np_\\theta(x) = \\frac{g_\\theta(x)}{Z(\\theta)} = \\frac{\\exp(f_\\theta(x))}{Z(\\theta)},\n\\quad \\text{where} \\quad Z(\\theta) = \\int \\exp(f_\\theta(x)) \\, dx\n\\]\nThis leads to the energy-based formulation, where \\(f_\\theta(x)\\) is interpreted as the negative energy. We can equivalently write:\n\\[\nE_\\theta(x) = -f_\\theta(x)\n\\quad \\Rightarrow \\quad\np_\\theta(x) = \\frac{\\exp(-E_\\theta(x))}{Z(\\theta)}\n\\]\nEnergy-Based Models (EBMs) follow this foundational idea: define a scoring function \\(f_\\theta(x)\\) that assigns high values to likely data points, then convert those scores into probabilities using exponentiation and normalization.\nThis perspective offers four key advantages:\n\nIt allows us to use flexible models (like deep neural networks) to assign unnormalized scores.\n\nIt separates concerns: one function ensures non-negativity (via exponentiation), and the partition function enforces normalization.\n\nIt lets us interpret \\(f_\\theta(x)\\) as an unnormalized log-probability, improving interpretability.\n\nIt connects naturally to well-known distributions (e.g., exponential family, Boltzmann distribution), making the formulation more general.\n\nThis formulation gives us the freedom to model complex distributions with any differentiable scoring function \\(f_\\theta(x)\\), while only requiring that we can compute or approximate its gradients.\n\n\n2.3.1 Summary\nWhether we express scores directly via \\(f_\\theta(x)\\) or indirectly through energy \\(E_\\theta(x)\\), the core idea remains the same:\n\nUse a flexible model to assign unnormalized scores\n\nNormalize those scores using the partition function \\(Z(\\theta)\\)\n\nThis gives EBMs the freedom to model complex data distributions using any differentiable function for \\(f_\\theta(x)\\) ‚Äî without requiring invertibility or exact likelihoods.\n\n\n\n2.3.2 Visualizing Energy Functions\nLet‚Äôs now build visual intuition for what these energy landscapes look like.\nEnergy-based models capture compatibility between variables using an energy function. In this example (adapted from Atcold, 2020), the energy function assigns lower values to pairs of variables \\((x, y)\\) that are more likely to co-occur ‚Äî and higher energy elsewhere.\n\n\n\nVisualizing Energy Field\n\n\nVisualizing the energy landscape \\(E(x_1, x_2)\\) ‚Äî lower energy corresponds to higher probability.\nThis shows how EBMs encode knowledge: valleys indicate high-likelihood (real) data, while peaks represent unlikely (noise) regions.\nThis kind of energy landscape is especially useful in practical tasks like image generation, where the model learns to assign low energy to realistic images and high energy to unrealistic ones. During inference, the model can generate new samples by exploring low-energy regions of this landscape."
  },
  {
    "objectID": "ebm.html#practical-applications",
    "href": "ebm.html#practical-applications",
    "title": "Energy Based Models (EBM)",
    "section": "3 Practical Applications",
    "text": "3 Practical Applications\nEnergy-Based Models (EBMs) offer unique benefits in scenarios where traditional models struggle. Below are two practical applications that demonstrate how EBMs shine in real-world settings.\n\n3.1 When You Don‚Äôt Need the Partition Function\nIn general, evaluating the full probability \\(p_\\theta(x)\\) requires computing the partition function \\(Z(\\theta)\\):\n\\[\np_\\theta(x) = \\frac{1}{Z(\\theta)} \\exp(f_\\theta(x))\n\\]\n\n\n\n\n\n\nKey Insight\nIn some applications, we don‚Äôt need the exact probability ‚Äî we only need to compare scores. This allows EBMs to be useful even when the partition function is intractable.\n\n\n\nWhen comparing two samples \\(x\\) and \\(x'\\), we can compute the ratio of their probabilities:\n\\[\n\\frac{p_\\theta(x)}{p_\\theta(x')} = \\exp(f_\\theta(x) - f_\\theta(x'))\n\\]\nThis lets us determine which input is more likely ‚Äî without ever computing \\(Z(\\theta)\\) ‚Äî a powerful advantage of EBMs.\nPractical Applications:\n\nAnomaly detection: Identify inputs with unusually low likelihood.\nDenoising: Prefer cleaner versions of corrupted data by comparing likelihoods.\nObject recognition: Assign the most likely label to an input image.\nSequence labeling: Predict tags (e.g., part-of-speech) for input tokens.\nImage restoration: Recover clean images from noisy inputs.\n\n\n\n\n\n\n\nNote\n\n\n\nReal-World Example\nIn anomaly detection, EBMs have been used to identify outliers in high-dimensional sensor data without computing exact probabilities ‚Äî simply by scoring input configurations and flagging those with unusually high energy.\n\n\n\n\n3.2 Product of Experts (Compositional Generation)\nIn some cases, we want to combine multiple expert models that each score different attributes of an input \\(\\mathbf{x}\\) ‚Äî for example, age, gender, or hairstyle. This is where Energy-Based Models (EBMs) shine through Product of Experts (PoE).\nSuppose you have three trained expert models \\(f_{\\theta_1}(x)\\), \\(f_{\\theta_2}(x)\\), and \\(f_{\\theta_3}(x)\\). A tempting idea is to combine their scores additively and exponentiate:\n\\[\n\\exp\\left(f_{\\theta_1}(x) + f_{\\theta_2}(x) + f_{\\theta_3}(x)\\right)\n\\]\nTo make this a valid probability distribution, we normalize:\n\\[\np_{\\theta_1, \\theta_2, \\theta_3}(x) = \\frac{1}{Z(\\theta_1, \\theta_2, \\theta_3)} \\exp\\left(f_{\\theta_1}(x) + f_{\\theta_2}(x) + f_{\\theta_3}(x)\\right)\n\\]\nThis behaves like a logical AND: if any expert assigns low score, the overall likelihood drops. This contrasts with mixture models (like Mixture of Gaussians), which behave more like OR.\n\n\n\n\n\n\nNote\n\n\n\nReal-World Example\nIn the figure below (Du et al., 2020), EBMs were used to model attributes like ‚Äúyoung‚Äù, ‚Äúfemale‚Äù, ‚Äúsmiling‚Äù, and ‚Äúwavy hair‚Äù. By combining these via Product of Experts, the model generated faces that satisfied multiple specific attributes simultaneously.\n\n\n\n\n\nSource: Du et al., 2020. Compositional Visual Generation with Energy Based Models"
  },
  {
    "objectID": "ebm.html#benefits-and-limitations-of-ebms",
    "href": "ebm.html#benefits-and-limitations-of-ebms",
    "title": "Energy Based Models (EBM)",
    "section": "4 Benefits and Limitations of EBMs",
    "text": "4 Benefits and Limitations of EBMs\n\n4.1 Key Benefits\nVery flexible model architectures\nNo need for invertibility, autoregressive factorization, or adversarial design.\nStable training\nCompared to GANs, EBMs can be more robust and easier to optimize.\nHigh sample quality\nCapable of modeling complex, multi-modal data distributions.\nFlexible composition\nEnergies can be combined to support multi-task objectives or structured learning.\n\n\n\n4.2 Limitations\nDespite their strengths, EBMs come with notable challenges:\nSampling is expensive\nNo direct way to sample from \\(p_\\theta(x)\\); MCMC methods are slow and scale poorly.\nLikelihood is intractable\nPartition function \\(Z(\\theta)\\) is hard to compute, and we can‚Äôt directly evaluate log-likelihood.\nTraining is indirect\nLearning requires reducing energy of incorrect samples, not just increasing for correct ones.\nNo feature learning (by default)\nEBMs don‚Äôt learn latent features unless explicitly structured (e.g., RBMs)."
  },
  {
    "objectID": "ebm.html#training-energy-based-models",
    "href": "ebm.html#training-energy-based-models",
    "title": "Energy Based Models (EBM)",
    "section": "5 Training Energy-Based Models",
    "text": "5 Training Energy-Based Models\nEBMs are trained to assign higher scores (lower energy) to observed data points, and lower scores (higher energy) to unobserved ones. This corresponds to maximizing the likelihood of training data.\n\\[\np_\\theta(x_{\\text{train}}) = \\frac{\\exp(f_\\theta(x_{\\text{train}}))}{Z(\\theta)}\n\\]\nThis expression tells us that increasing the score for \\(x_{\\text{train}}\\) is not enough ‚Äî we must also decrease scores for other \\(x\\) to reduce \\(Z(\\theta)\\) and make the probability higher relatively.\n\n\n5.1 Log-Likelihood and Its Gradient\nTo train EBMs, we compute the gradient of the log-likelihood with respect to parameters \\(\\theta\\).\nWe start by writing the log-likelihood:\n\\[\n\\log p_\\theta(x_{\\text{train}}) = f_\\theta(x_{\\text{train}}) - \\log Z(\\theta)\n\\]\nTaking the gradient with respect to \\(\\theta\\):\n\\[\n\\nabla_\\theta \\log p_\\theta(x_{\\text{train}}) = \\nabla_\\theta f_\\theta(x_{\\text{train}}) - \\nabla_\\theta \\log Z(\\theta)\n\\]\nTo compute this, we need the gradient of the log partition function:\n\\[\nZ(\\theta) = \\int \\exp(f_\\theta(x))\\, dx\n\\]\nApplying the chain rule:\n\\[\n\\nabla_\\theta \\log Z(\\theta)\n= \\frac{1}{Z(\\theta)} \\int \\exp(f_\\theta(x)) \\nabla_\\theta f_\\theta(x)\\, dx\n= \\mathbb{E}_{x \\sim p_\\theta} \\left[ \\nabla_\\theta f_\\theta(x) \\right]\n\\]\nSubstitute this back:\n\\[\n\\nabla_\\theta \\log p_\\theta(x_{\\text{train}})\n= \\nabla_\\theta f_\\theta(x_{\\text{train}}) - \\mathbb{E}_{x \\sim p_\\theta} \\left[ \\nabla_\\theta f_\\theta(x) \\right]\n\\]\nThe first term is straightforward ‚Äî it‚Äôs the gradient of the model‚Äôs score on the training point.\nBut the second term, the expectation over model samples, is difficult. It requires drawing samples from \\(p_\\theta(x)\\), which in turn depends on the intractable normalization constant \\(Z(\\theta)\\).\nTo deal with this, we use sampling-based approximations like Contrastive Divergence.\n\n\n\n5.2 Contrastive Divergence\nSince computing the true gradient requires sampling from \\(p_\\theta(x)\\), which is intractable due to the partition function \\(Z(\\theta)\\), we use Contrastive Divergence as an efficient approximation.\nWe approximate the expectation:\n\\[\n\\mathbb{E}_{x \\sim p_\\theta} \\left[ \\nabla_\\theta f_\\theta(x) \\right] \\approx \\nabla_\\theta f_\\theta(x_{\\text{sample}})\n\\]\nThis gives:\n\\[\n\\nabla_\\theta \\log p_\\theta(x_{\\text{train}}) \\approx \\nabla_\\theta f_\\theta(x_{\\text{train}}) - \\nabla_\\theta f_\\theta(x_{\\text{sample}})\n= \\nabla_\\theta \\left( f_\\theta(x_{\\text{train}}) - f_\\theta(x_{\\text{sample}}) \\right)\n\\]\nContrastive Divergence Algorithm:\n\nSample \\(x_{\\text{sample}} \\sim p_\\theta\\) (typically via MCMC)\nTake a gradient step on:\n\n\\[\n\\nabla_\\theta \\left( f_\\theta(x_{\\text{train}}) - f_\\theta(x_{\\text{sample}}) \\right)\n\\]\nThis encourages the model to increase the score of the training sample and decrease the score of samples it currently believes are likely.\n\n\n\n\n\n\nEBM Training Recap\n- Want: High scores (low energy) for real data\n- Avoid: High scores for incorrect data\n- Can‚Äôt compute exact gradient due to \\(Z(\\theta)\\)\n- So: Approximate using Monte Carlo sample \\(\\sim p_\\theta(x)\\)\n\n\n\n\n\n5.2.1 Intuition Recap\n\nPull up: Increase the score (lower the energy) of the real training sample \\(\\nabla_\\theta f_\\theta(x_{\\text{train}})\\)\nPush down: Decrease the score of samples from the model \\(\\nabla_\\theta f_\\theta(x_{\\text{sample}})\\)\nThis sharpens the model‚Äôs belief in real data and corrects high-scoring regions where it is currently overconfident.\n\n During training, EBMs increase the score of correct samples and decrease the score of incorrect ones.\n\nSource: course material from CS236: Deep Generative Models"
  },
  {
    "objectID": "ebm.html#sampling-from-energy-based-models",
    "href": "ebm.html#sampling-from-energy-based-models",
    "title": "Energy Based Models (EBM)",
    "section": "6 Sampling from Energy-Based Models",
    "text": "6 Sampling from Energy-Based Models\nRecall that EBMs define a probability distribution as:\n\\[\np_\\theta(x) = \\frac{1}{Z(\\theta)} \\exp(f_\\theta(x))\n\\]\nUnlike autoregressive or flow models, there is no direct way to sample from \\(p_\\theta(x)\\) because we cannot easily compute how likely each possible sample is. That‚Äôs because the normalization term \\(Z(\\theta)\\) is intractable.\nHowever, we can still compare two samples using a key insight:\n\n\n\n\n\n\nKey Insight\nWe can still compare two samples \\(x\\) and \\(x'\\) without needing \\(Z(\\theta)\\):\n\\[\n\\frac{p_\\theta(x)}{p_\\theta(x')} = \\exp(f_\\theta(x) - f_\\theta(x'))\n\\]\nThis property is useful for tasks like ranking, anomaly detection, and denoising.\n\n\n\nWhile we can‚Äôt sample from \\(p_\\theta(x)\\) directly due to the intractable \\(Z(\\theta)\\), we can still generate approximate samples using Markov Chain Monte Carlo (MCMC) methods.\n\n\n6.1 Metropolis-Hastings (MH) MCMC\nMetropolis-Hastings proposes samples and accepts or rejects them based on how much they improve the energy score.\nTo sample from \\(p_\\theta(x)\\), we use an iterative approach like MCMC:\n\nInitialize \\(x^0\\) randomly\n\nPropose a new sample: \\(x' = x^t + \\text{noise}\\)\n\nAccept or reject based on scores:\n\nIf \\(f_\\theta(x') &gt; f_\\theta(x^t)\\), set \\(x^{t+1} = x'\\)\nElse set \\(x^{t+1} = x'\\) with probability \\(\\exp(f_\\theta(x') - f_\\theta(x^t))\\)\nOtherwise, set \\(x^{t+1} = x^t\\)\n\nRepeat this process until the chain converges\n\nPros:\n- General-purpose\n- Guaranteed to converge to \\(p_\\theta(x)\\) under mild conditions\nCons:\n- Can take a very long time to convergence - Sensitive to proposal distribution\n- Computationally expensive in high dimensions\n\n\n6.2 Unadjusted Langevin MCMC (ULA)\nULA improves over random-walk MH by using gradient information to guide proposals.\nTo sample from \\(p_\\theta(x)\\), Unadjusted Langevin MCMC uses gradient information to guide proposals:\n\nInitialize \\(x^0 \\sim \\pi(x)\\)\n\nRepeat for \\(t = 0, 1, 2, \\dots, T - 1\\):\n\nSample \\(z^t \\sim \\mathcal{N}(0, I)\\)\n\nUpdate: \\(x^{t+1} = x^t + \\epsilon \\nabla_x \\log p_\\theta(x^t) + \\sqrt{2\\epsilon} z^t\\)\n\n\nFor EBMs, since \\(\\nabla_x \\log p_\\theta(x) = \\nabla_x f_\\theta(x)\\) the update becomes:\n\\[\nx^{t+1} = x^t + \\epsilon \\nabla_x f_\\theta(x^t) + \\sqrt{2\\epsilon} z^t\n\\]\nPros:\n- Uses gradient to improve proposal\n- Often faster mixing than random-walk methods\nCons:\n- Still requires many steps for good convergence\n- Sensitive to step size \\(\\epsilon\\)\n\n\n6.3 Adjusted Langevin MCMC (ALA)\nALA fixes the bias in ULA by using Metropolis-Hastings-style acceptance to ensure correct sampling.\nTo sample from \\(p_\\theta(x)\\), Adjusted Langevin MCMC applies a step after each Langevin update to ensure samples follow the correct stationary distribution.\nThis makes it a corrected version of ULA with proper stationary distribution.\n\n \\(x^0 \\sim \\pi(x)\\)\n\n for \\(t = 0, 1, 2, \\dots, T - 1\\):\n\nSample \\(z^t \\sim \\mathcal{N}(0, I)\\)\n\nPropose: \\(x' = x^t + \\epsilon \\nabla_x \\log p_\\theta(x^t) + \\sqrt{2\\epsilon} z^t\\)\nForward proposal: \\(q(x^{t+1} \\mid x^t) = \\mathcal{N}\\left(x^{t+1} \\mid x^t + \\epsilon \\nabla_x \\log p_\\theta(x^t),\\ 2\\epsilon I\\right)\\)\nReverse proposal: \\(q(x^t \\mid x^{t+1}) = \\mathcal{N}\\left(x^t \\mid x^{t+1} + \\epsilon \\nabla_x \\log p_\\theta(x^{t+1}),\\ 2\\epsilon I\\right)\\)\nAccept \\(x\\) with probability \\(\\alpha = \\min\\left(1, \\frac{p_\\theta(x') \\cdot q(x^t \\mid x')}{p_\\theta(x^t) \\cdot q(x' \\mid x^t)}\\right)\\)\n\nIf accepted: \\(x^{t+1} = x'\\)\n\nOtherwise: \\(x^{t+1} = x^t\\)\n\n\n\nFor EBMs, since\n\\[\n\\nabla_x \\log p_\\theta(x) = \\nabla_x f_\\theta(x)\n\\] and \\[  \nq(x' \\mid x^t) = \\mathcal{N}\\left(x' \\mid x^t + \\epsilon \\nabla_x f_\\theta(x^t), 2\\epsilon I\\right)\n\\]\nthe proposal becomes:\n\\[\nx' = x^t + \\epsilon \\nabla_x f_\\theta(x^t) + \\sqrt{2\\epsilon} z^t\n\\]\n\n\n\n6.4 Summary\nAll these methods aim to sample from \\(p_\\theta(x)\\), but differ in how they explore the space:\n\nMH is simple but can be inefficient.\n\nULA is gradient-guided and faster but biased.\n\nAdjusted Langevin corrects ULA using MH-style acceptance.\n\n\n\n\n\n\n\n\n\nMethod\nKey Advantage\nKey Limitation\n\n\n\n\nMH (Metropolis-Hastings)\nGeneral-purpose; unbiased under mild conditions\nCan be inefficient and slow to converge\n\n\nULA (Unadjusted Langevin)\nGradient-guided; faster mixing than MH\nBiased sampling; sensitive to step size\n\n\nALA (Adjusted Langevin)\nCombines ULA with MH for correctness\nMore complex and computationally expensive\n\n\n\nSampling is a core challenge in EBMs ‚Äî especially because we need to sample during every training step when using contrastive divergence."
  },
  {
    "objectID": "ebm.html#ebm-recap",
    "href": "ebm.html#ebm-recap",
    "title": "Energy Based Models (EBM)",
    "section": "7 üß© EBM Recap",
    "text": "7 üß© EBM Recap\nEnergy-Based Models (EBMs) offer a flexible and elegant alternative to traditional generative models by focusing on scoring functions rather than prescribing fixed model architectures. By defining an unnormalized score over inputs and converting it into a probability via a partition function, EBMs avoid the structural constraints of VAEs, GANs, or flows.\nKey ideas: - EBMs define probabilities as:\n\\[\n  p_\\theta(x) = \\frac{1}{Z(\\theta)} \\exp(f_\\theta(x))\n  \\] - The energy function \\(E_\\theta(x) = -f_\\theta(x)\\) creates a landscape where low energy = high probability.\n- EBMs excel when exact likelihood is unnecessary (e.g., denoising, anomaly detection, structured generation).\n- They support modular composition through techniques like Product of Experts (PoE).\n- Training involves score-based contrastive learning, and sampling is powered by MCMC methods.\nDespite challenges like intractable sampling and likelihood computation, EBMs continue to gain traction due to their conceptual clarity, compositional flexibility, and alignment with physics-inspired learning paradigms."
  },
  {
    "objectID": "ebm.html#references",
    "href": "ebm.html#references",
    "title": "Energy Based Models (EBM)",
    "section": "8 üìö References",
    "text": "8 üìö References\n[1] Atcold, Y. (2020). NYU Deep Learning Spring 2020 ‚Äì Week 07: Energy-Based Models. Retrieved from https://atcold.github.io/NYU-DLSP20/en/week07/07-1/\n[2] LeCun, Y., Hinton, G., & Bengio, Y. (2021). A Path Towards Autonomous Machine Intelligence. arXiv. Retrieved from https://arxiv.org/pdf/2101.03288\n[3] MIT. (2022). Energy-Based Models ‚Äì MIT Class Project. Retrieved from https://energy-based-model.github.io/Energy-based-Model-MIT/\n[4] University of Amsterdam. (2021). Deep Energy Models ‚Äì UvA DL Notebooks. Retrieved from https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial8/Deep_Energy_Models.html\n[5] MIT. (2022). Compositional Generation and Inference with Energy-Based Models. Retrieved from https://energy-based-model.github.io/compositional-generation-inference/"
  },
  {
    "objectID": "vae_mnist.html",
    "href": "vae_mnist.html",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "",
    "text": "This notebook explains a Variational Autoencoder (VAE) trained on the MNIST dataset using PyTorch.\nEach step is annotated with detailed comments to help beginners understand what‚Äôs happening.\n!pip install torch torchvision"
  },
  {
    "objectID": "vae_mnist.html#import-required-libraries",
    "href": "vae_mnist.html#import-required-libraries",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "1 1. Import Required Libraries",
    "text": "1 1. Import Required Libraries\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torchvision\nimport torchvision.transforms as transforms\nfrom torch.utils.data import DataLoader\nimport matplotlib.pyplot as plt\nimport numpy as np"
  },
  {
    "objectID": "vae_mnist.html#load-and-prepare-the-mnist-dataset",
    "href": "vae_mnist.html#load-and-prepare-the-mnist-dataset",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "2 2. Load and Prepare the MNIST Dataset",
    "text": "2 2. Load and Prepare the MNIST Dataset\n\n# We transform MNIST images into tensors.\ntransform = transforms.ToTensor()\n\n# Download and load the training data\ntrain_data = torchvision.datasets.MNIST(root='./data', train=True, download=True, transform=transform)\n\n# DataLoader for batching and shuffling\ntrain_loader = DataLoader(train_data, batch_size=128, shuffle=True)"
  },
  {
    "objectID": "vae_mnist.html#define-the-vae-model",
    "href": "vae_mnist.html#define-the-vae-model",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "3 3. Define the VAE Model",
    "text": "3 3. Define the VAE Model\n\nclass VAE(nn.Module):\n    def __init__(self, input_dim=784, hidden_dim=400, latent_dim=2):\n        super(VAE, self).__init__()\n        # Encoder layers: input -&gt; hidden -&gt; (mu, logvar)\n        self.fc1 = nn.Linear(input_dim, hidden_dim)\n        self.fc_mu = nn.Linear(hidden_dim, latent_dim)      # outputs mean of q(z|x)\n        self.fc_logvar = nn.Linear(hidden_dim, latent_dim)  # outputs log-variance of q(z|x)\n\n        # Decoder layers: latent -&gt; hidden -&gt; reconstruction\n        self.fc3 = nn.Linear(latent_dim, hidden_dim)\n        self.fc4 = nn.Linear(hidden_dim, input_dim)\n\n    def encode(self, x):\n        # Apply a hidden layer then split into mean and logvar\n        h = F.relu(self.fc1(x))\n        mu = self.fc_mu(h)\n        logvar = self.fc_logvar(h)\n        return mu, logvar\n\n    def reparameterize(self, mu, logvar):\n        # Apply the reparameterization trick\n        std = torch.exp(0.5 * logvar)      # standard deviation\n        eps = torch.randn_like(std)        # random normal noise\n        return mu + eps * std              # sample z\n\n    def decode(self, z):\n        # Reconstruct input from latent representation\n        h = F.relu(self.fc3(z))\n        return torch.sigmoid(self.fc4(h))  # Output in [0, 1] range for binary MNIST\n\n    def forward(self, x):\n        # Full VAE forward pass\n        mu, logvar = self.encode(x)\n        z = self.reparameterize(mu, logvar)\n        recon_x = self.decode(z)\n        return recon_x, mu, logvar"
  },
  {
    "objectID": "vae_mnist.html#define-the-elbo-loss",
    "href": "vae_mnist.html#define-the-elbo-loss",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "4 4. Define the ELBO Loss",
    "text": "4 4. Define the ELBO Loss\n\ndef elbo_loss(recon_x, x, mu, logvar):\n    # Binary cross-entropy for reconstruction\n    BCE = F.binary_cross_entropy(recon_x, x, reduction='sum')\n\n    # KL divergence term to regularize q(z|x) against standard normal p(z)\n    KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())\n\n    # Total loss is negative ELBO\n    return BCE + KLD"
  },
  {
    "objectID": "vae_mnist.html#train-the-vae",
    "href": "vae_mnist.html#train-the-vae",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "5 5. Train the VAE",
    "text": "5 5. Train the VAE\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = VAE().to(device)\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\n\nepochs = 5\nfor epoch in range(epochs):\n    model.train()\n    total_loss = 0\n    for x, _ in train_loader:\n        x = x.view(-1, 784).to(device)               # Flatten 28x28 images into 784 vectors\n        recon_x, mu, logvar = model(x)               # Forward pass\n        loss = elbo_loss(recon_x, x, mu, logvar)     # Compute loss\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        total_loss += loss.item()\n    print(f\"Epoch {epoch+1}, Loss: {total_loss / len(train_loader.dataset):.2f}\")"
  },
  {
    "objectID": "vae_mnist.html#visualize-original-and-reconstructed-digits",
    "href": "vae_mnist.html#visualize-original-and-reconstructed-digits",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "6 6. Visualize Original and Reconstructed Digits",
    "text": "6 6. Visualize Original and Reconstructed Digits\n\nmodel.eval()\nwith torch.no_grad():\n    x, _ = next(iter(train_loader))\n    x = x.view(-1, 784).to(device)\n    recon_x, _, _ = model(x)\n\n    # Convert back to image format\n    x = x.view(-1, 1, 28, 28).cpu()\n    recon_x = recon_x.view(-1, 1, 28, 28).cpu()\n\n    fig, axs = plt.subplots(2, 10, figsize=(15, 3))\n    for i in range(10):\n        axs[0, i].imshow(x[i][0], cmap='gray')\n        axs[0, i].axis('off')\n        axs[1, i].imshow(recon_x[i][0], cmap='gray')\n        axs[1, i].axis('off')\n    axs[0, 0].set_ylabel(\"Original\", fontsize=12)\n    axs[1, 0].set_ylabel(\"Reconstruction\", fontsize=12)\n    plt.tight_layout()\n    plt.show()"
  },
  {
    "objectID": "vae_mnist.html#visualize-latent-space",
    "href": "vae_mnist.html#visualize-latent-space",
    "title": "Variational Autoencoder (VAE) on MNIST ‚Äî Beginner Friendly Walkthrough",
    "section": "7 7. Visualize Latent Space",
    "text": "7 7. Visualize Latent Space\n\nimport seaborn as sns\n\nmodel.eval()\nall_z = []\nall_labels = []\n\n# Go through a few batches and collect latent representations\nwith torch.no_grad():\n    for x, y in train_loader:\n        x = x.view(-1, 784).to(device)\n        mu, _ = model.encode(x)  # use the mean as representation\n        all_z.append(mu.cpu())\n        all_labels.append(y)\n\n# Concatenate all batches\nz = torch.cat(all_z, dim=0).numpy()\nlabels = torch.cat(all_labels, dim=0).numpy()\n\n# Plot with seaborn\nplt.figure(figsize=(8, 6))\nsns.scatterplot(x=z[:, 0], y=z[:, 1], hue=labels, palette=\"tab10\", s=15)\nplt.title(\"Latent Space Visualization (using Œº)\")\nplt.xlabel(\"z[0]\")\nplt.ylabel(\"z[1]\")\nplt.legend(title=\"Digit\", bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "ebm_mnist.html",
    "href": "ebm_mnist.html",
    "title": "Energy-Based Model (EBM) on MNIST",
    "section": "",
    "text": "This notebook implements a basic EBM using PyTorch and MNIST.\n\n# Install and import dependencies\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torchvision import datasets, transforms\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom torch.utils.data import TensorDataset, DataLoader\n\nimport torch.optim as optim\n\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n\nBATCH_SIZE = 128\nLEARNING_RATE = 0.0001\nnum_epochs = 10\n\n\n# ------------------------------------------\n# Load the MNIST dataset in PyTorch\n# ------------------------------------------\n\n# Step 1: Define a transform to convert images to PyTorch tensors\ntransform = transforms.Compose([\n    transforms.ToTensor(),  # Converts images to range [0, 1] as float32 tensors\n])\n\n# Step 2: Download and load the training and test sets\ntrain_dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transform)\ntest_dataset  = datasets.MNIST(root='./data', train=False, download=True, transform=transform)\n\n# Step 3: Create DataLoaders for easy batch access\ntrain_loader = torch.utils.data.DataLoader(train_dataset, batch_size=64, shuffle=True)\ntest_loader  = torch.utils.data.DataLoader(test_dataset, batch_size=64, shuffle=False)\n\n\n# ------------------------------------------\n# Custom preprocessing function (if needed)\n# ------------------------------------------\n\ndef preprocess_pytorch(images):\n    \"\"\"\n    Normalize and reshape the images similar to your original TensorFlow preprocessing.\n\n    - Normalize pixel values from [0, 255] ‚Üí [-1, 1]\n    - Pad from 28x28 ‚Üí 32x32 with constant value -1\n    - Add a channel dimension if not present\n    \"\"\"\n\n    # Scale from [0, 1] to [-1, 1]\n    images = images * 2 - 1\n\n    # images: shape (batch_size, 1, 28, 28) ‚Üí pad to (batch_size, 1, 32, 32)\n    images = F.pad(images, pad=(2, 2, 2, 2), mode='constant', value=-1.0)\n\n    return images\n\n\ntransform = transforms.Compose([\n    transforms.ToTensor(),         # Converts image to [0, 1] tensor\n    transforms.Lambda(preprocess_pytorch)  # Then normalize and pad\n])\n\n\n# Download MNIST dataset\nmnist_data = datasets.MNIST(root='.', train=True, download=True)\nx_train = mnist_data.data.numpy()\n\nmnist_test = datasets.MNIST(root='.', train=False, download=True)\nx_test = mnist_test.data.numpy()\n\n\n# Convert numpy arrays to PyTorch tensors and add channel dimension\nx_train_tensor = torch.tensor(x_train, dtype=torch.float32).unsqueeze(1)  # shape: [B, 1, 28, 28]\nx_test_tensor = torch.tensor(x_test, dtype=torch.float32).unsqueeze(1)    # shape: [B, 1, 28, 28]\n\n# Create TensorDatasets from tensors\ntrain_dataset = TensorDataset(x_train_tensor)\ntest_dataset = TensorDataset(x_test_tensor)\n\n# Wrap datasets in DataLoader to enable batching and shuffling\ntrain_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)\ntest_loader = DataLoader(test_dataset, batch_size=BATCH_SIZE, shuffle=False)\n\n\n# Define a PyTorch EBM model similar to your TensorFlow implementation\nclass EBM(nn.Module):\n    def __init__(self, image_size=28, channels=1):\n        super(EBM, self).__init__()\n\n        # Convolutional layers with Swish (SiLU) activations\n        self.conv1 = nn.Conv2d(channels, 16, kernel_size=5, stride=2, padding=2)\n        self.conv2 = nn.Conv2d(16, 32, kernel_size=3, stride=2, padding=1)\n        self.conv3 = nn.Conv2d(32, 64, kernel_size=3, stride=2, padding=1)\n        self.conv4 = nn.Conv2d(64, 64, kernel_size=3, stride=2, padding=1)\n\n        # Calculate the flattened output size after 4 conv layers\n        conv_output_size = image_size // (2**4)  # 4 strides of 2\n        flattened_dim = 64 * conv_output_size * conv_output_size\n\n        # Dense layers\n        self.fc1 = nn.Linear(flattened_dim, 64)\n        self.fc2 = nn.Linear(64, 1)  # Single energy output\n\n    def forward(self, x):\n        # Swish activation is available as F.silu in PyTorch\n        x = F.silu(self.conv1(x))\n        x = F.silu(self.conv2(x))\n        x = F.silu(self.conv3(x))\n        x = F.silu(self.conv4(x))\n\n        x = x.view(x.size(0), -1)  # Flatten for dense layers\n        x = F.silu(self.fc1(x))\n        energy = self.fc2(x)  # Output energy (unnormalized score)\n        return energy\n\n\ndef generate_samples(\n    model,                 # The energy-based model\n    inp_imgs,              # Initial images (random noise or seeds)\n    steps,                 # Number of Langevin steps\n    step_size,             # Step size (learning rate)\n    noise,                 # Stddev of added Gaussian noise\n    return_img_per_step=False,  # Whether to save images at each step\n):\n    imgs_per_step = []\n\n    inp_imgs = inp_imgs.clone().detach().to(device).requires_grad_(True)\n\n    for _ in range(steps):\n        # Step 1: Add Gaussian noise to encourage exploration\n        inp_imgs.data += torch.randn_like(inp_imgs) * noise\n\n        # Step 2: Clamp values to stay in [-1, 1] range (MNIST normalized)\n        inp_imgs.data = torch.clamp(inp_imgs.data, -1.0, 1.0)\n\n        # Step 3: Forward pass to compute score (energy)\n        out_score = model(inp_imgs)\n\n        # Step 4: Compute gradient of score w.r.t. input image\n        grads = torch.autograd.grad(outputs=out_score.sum(), inputs=inp_imgs)[0]\n\n        # Step 5: Clip gradients for stability\n        grads = torch.clamp(grads, -GRADIENT_CLIP, GRADIENT_CLIP)\n\n        # Step 6: Gradient ascent step on input image\n        inp_imgs.data += step_size * grads\n\n        # Step 7: Clamp again to stay in valid range\n        inp_imgs.data = torch.clamp(inp_imgs.data, -1.0, 1.0)\n\n        if return_img_per_step:\n            imgs_per_step.append(inp_imgs.detach().clone())\n\n    if return_img_per_step:\n        return torch.stack(imgs_per_step, dim=0)\n    else:\n        return inp_imgs.detach()\n\n\nclass EBM(nn.Module):\n    def __init__(self, base_model, alpha=0.1):\n        super().__init__()\n        self.model = base_model  # scoring network\n        self.alpha = alpha       # regularization weight\n\n    def forward(self, x):\n        return self.model(x).squeeze()\n\ndef compute_loss(model, real_imgs, steps, step_size, noise_scale):\n    \"\"\"\n    Contrastive divergence loss between real data and fake (noise) samples.\n    \"\"\"\n    batch_size = real_imgs.size(0)\n\n    # Generate fake images from random noise\n    fake_imgs = torch.empty_like(real_imgs).uniform_(-1, 1).to(real_imgs.device)\n    fake_imgs.requires_grad = True\n\n    # Langevin dynamics steps (optional: here 0 steps means no update)\n    for _ in range(steps):\n        fake_imgs.data += torch.randn_like(fake_imgs) * noise_scale\n        fake_imgs.data = torch.clamp(fake_imgs.data, -1, 1)\n\n        energy = model(fake_imgs)\n        grads = torch.autograd.grad(energy.sum(), fake_imgs, create_graph=True)[0]\n        fake_imgs.data += step_size * grads\n        fake_imgs.data = torch.clamp(fake_imgs.data, -1, 1)\n\n    # Get scores\n    real_scores = model(real_imgs)\n    fake_scores = model(fake_imgs.detach())\n\n    # Contrastive Divergence (CD-1) Loss\n    cdiv_loss = fake_scores.mean() - real_scores.mean()\n\n    # Regularization: penalize high scores\n    reg_loss = model.alpha * ((real_scores ** 2).mean() + (fake_scores ** 2).mean())\n\n    total_loss = cdiv_loss + reg_loss\n\n    return total_loss, cdiv_loss.item(), reg_loss.item(), real_scores.mean().item(), fake_scores.mean().item()\n\n\nclass ScoreNet(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Conv2d(1, 32, kernel_size=3, stride=2, padding=1),  # [batch, 32, 14, 14]\n            nn.ReLU(),\n            nn.Conv2d(32, 64, kernel_size=3, stride=2, padding=1), # [batch, 64, 7, 7]\n            nn.ReLU(),\n            nn.Flatten(),\n            nn.Linear(64 * 7 * 7, 128),\n            nn.ReLU(),\n            nn.Linear(128, 1)  # Final scalar output (energy score)\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\nbase_model = ScoreNet()\nebm = EBM(base_model=base_model, alpha=0.1)\n\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nebm = ebm.to(device)  # Move the model to the device\n\n\noptimizer = optim.Adam(ebm.parameters(), lr=LEARNING_RATE)\n\n\nfor epoch in range(num_epochs):\n    for batch in train_loader:\n        if isinstance(batch, (list, tuple)):\n            real_images = batch[0]\n        else:\n            real_images = batch\n\n        real_images = real_images.to(device)\n        real_images.requires_grad = True\n\n        # Forward pass\n        scores = ebm(real_images)\n        loss = -scores.mean()  # Basic negative log-score loss\n\n        # Backward pass and optimization\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n    print(f\"Epoch {epoch + 1}/{num_epochs}, Loss: {loss.item():.4f}\")\n\nEpoch 1/10, Loss: -1949711.2500\nEpoch 2/10, Loss: -34621388.0000\nEpoch 3/10, Loss: -168554992.0000\nEpoch 4/10, Loss: -460923584.0000\nEpoch 5/10, Loss: -974023040.0000\nEpoch 6/10, Loss: -1813268352.0000\nEpoch 7/10, Loss: -2972573696.0000\nEpoch 8/10, Loss: -4526898176.0000\nEpoch 9/10, Loss: -6693363200.0000\nEpoch 10/10, Loss: -9541715968.0000\n\n\n\n# üß† Langevin Dynamics Sampling Function\ndef generate_samples(model, inp_imgs, steps, step_size, noise, return_img_per_step=False):\n    inp_imgs = inp_imgs.clone().detach().to(device).requires_grad_()  # Make it a leaf tensor with grad\n    imgs_per_step = []\n\n    for _ in range(steps):\n        # Add Gaussian noise and clip to valid range\n        inp_imgs = inp_imgs + noise * torch.randn_like(inp_imgs)\n        inp_imgs = torch.clamp(inp_imgs, -1.0, 1.0)\n        inp_imgs.requires_grad_()  # Re-enable grad tracking (necessary after in-place ops)\n\n        # Compute gradients of score wrt input\n        scores = model(inp_imgs)\n        grads = torch.autograd.grad(scores.sum(), inp_imgs)[0]\n\n        # Langevin update\n        inp_imgs = inp_imgs + step_size * grads\n        inp_imgs = torch.clamp(inp_imgs, -1.0, 1.0)\n\n        if return_img_per_step:\n            imgs_per_step.append(inp_imgs.detach().cpu())\n\n    if return_img_per_step:\n        return torch.stack(imgs_per_step)\n    else:\n        return inp_imgs.detach().cpu()\n\n\n# Starting noise image (e.g., 10 images of 28x28x1)\nstart_imgs = torch.rand(10, 1, 28, 28).to(device) * 2 - 1\n\n# Run Langevin sampling\ngen_imgs = generate_samples(\n    model=ebm,\n    inp_imgs=start_imgs,\n    steps=1000,\n    step_size=0.1,\n    noise=0.005,\n    return_img_per_step=True\n)\n\n# Visualize final images\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 10, figsize=(12, 2))\nfor i, ax in enumerate(axes):\n    ax.imshow(gen_imgs[-1][i][0], cmap=\"gray\")\n    ax.axis(\"off\")\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "vae_faces.html",
    "href": "vae_faces.html",
    "title": "Face Generation with Convolutional VAE",
    "section": "",
    "text": "This notebook implements a convolutional variational autoencoder (VAE) trained on the CelebA face dataset using PyTorch.\nIt uses convolutional layers to encode and decode 64x64 face images, and demonstrates generation by sampling from the latent space.\n!pip install torch torchvision matplotlib\n# Enable autoreloading in Jupyter (if applicable)\n%load_ext autoreload\n%autoreload 2\n\n# Core libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.stats import norm  # Used for visualizing latent distributions\n\n# PyTorch imports\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nfrom torch.utils.data import DataLoader, Dataset\nimport torchvision\nfrom torchvision import transforms, utils\n# Hyperparameters\n\nIMAGE_SIZE = 32        # Input image resolution (32x32)\nCHANNELS = 3           # Number of color channels (RGB)\nBATCH_SIZE = 128       # Batch size for training\nNUM_FEATURES = 128     # Hidden layer size or intermediate feature size\nZ_DIM = 200            # Dimensionality of the latent space\nLEARNING_RATE = 5e-4   # Learning rate for optimizer\nEPOCHS = 1             # Number of training epochs\nBETA = 2000            # Weight for KL divergence term in loss (used in beta-VAE)"
  },
  {
    "objectID": "vae_faces.html#loading-and-preprocessing-the-celeba-dataset",
    "href": "vae_faces.html#loading-and-preprocessing-the-celeba-dataset",
    "title": "Face Generation with Convolutional VAE",
    "section": "0.1 Loading and Preprocessing the CelebA Dataset",
    "text": "0.1 Loading and Preprocessing the CelebA Dataset\n\nfrom torchvision.datasets import CelebA\nfrom torchvision import transforms\nfrom torch.utils.data import DataLoader\n\n# Transform pipeline: resize and convert to tensor\ntransform = transforms.Compose([\n    transforms.Resize((IMAGE_SIZE, IMAGE_SIZE)),\n    transforms.ToTensor()\n])\n\n# Load CelebA dataset\ntrain_data = CelebA(\n    root=\"./data\",                      # Where to download/save the data\n    split=\"train\",                      # Options: \"train\", \"valid\", \"test\", or \"all\"\n    download=True,                      # Download if not already there\n    transform=transform\n)\n\n# DataLoader\ntrain_loader = DataLoader(\n    train_data,\n    batch_size=BATCH_SIZE,\n    shuffle=True,\n    num_workers=2,\n    pin_memory=True\n)\n\n\nval_data = CelebA(\n    root=\"./data\",\n    split=\"valid\",\n    download=True,\n    transform=transform\n)\n\nval_loader = DataLoader(\n    val_data,\n    batch_size=BATCH_SIZE,\n    shuffle=False,\n    num_workers=2,\n    pin_memory=True\n)"
  },
  {
    "objectID": "vae_faces.html#visualizing-training-data",
    "href": "vae_faces.html#visualizing-training-data",
    "title": "Face Generation with Convolutional VAE",
    "section": "0.2 Visualizing Training Data",
    "text": "0.2 Visualizing Training Data\n\ndef sample_batch(dataloader, num_samples=16):\n    \"\"\"\n    Sample one batch from the dataloader and return the first `num_samples` images.\n    \"\"\"\n    for images, _ in dataloader:\n        return images[:num_samples]\n\n\nimport matplotlib.pyplot as plt\nfrom torchvision.utils import make_grid\n\ndef display(images, cmap=None, nrow=8):\n    \"\"\"\n    Display a grid of images using matplotlib.\n    \"\"\"\n    grid = make_grid(images, nrow=nrow, padding=2, normalize=True)\n    np_img = grid.permute(1, 2, 0).cpu().numpy()\n\n    plt.figure(figsize=(10, 5))\n    plt.imshow(np_img, cmap=cmap)\n    plt.axis('off')\n    plt.show()\n\n\ntrain_sample = sample_batch(train_loader, num_samples=16)\ndisplay(train_sample)"
  },
  {
    "objectID": "vae_faces.html#reparameterization-trick",
    "href": "vae_faces.html#reparameterization-trick",
    "title": "Face Generation with Convolutional VAE",
    "section": "0.3 Reparameterization Trick",
    "text": "0.3 Reparameterization Trick\n\ndef reparameterize(z_mean, z_log_var):\n    \"\"\"\n    Reparameterization trick: z = mu + sigma * epsilon\n    where epsilon ~ N(0, I)\n    \"\"\"\n    std = torch.exp(0.5 * z_log_var)\n    eps = torch.randn_like(std)\n    return z_mean + eps * std"
  },
  {
    "objectID": "vae_faces.html#encoder",
    "href": "vae_faces.html#encoder",
    "title": "Face Generation with Convolutional VAE",
    "section": "0.4 Encoder",
    "text": "0.4 Encoder\n\nclass Encoder(nn.Module):\n    def __init__(self, z_dim):\n        super().__init__()\n        self.conv = nn.Sequential(\n            nn.Conv2d(CHANNELS, NUM_FEATURES, kernel_size=3, stride=2, padding=1),  # 32 ‚Üí 16\n            nn.BatchNorm2d(NUM_FEATURES),\n            nn.LeakyReLU(),\n\n            nn.Conv2d(NUM_FEATURES, NUM_FEATURES, kernel_size=3, stride=2, padding=1),  # 16 ‚Üí 8\n            nn.BatchNorm2d(NUM_FEATURES),\n            nn.LeakyReLU(),\n\n            nn.Conv2d(NUM_FEATURES, NUM_FEATURES, kernel_size=3, stride=2, padding=1),  # 8 ‚Üí 4\n            nn.BatchNorm2d(NUM_FEATURES),\n            nn.LeakyReLU(),\n\n            nn.Conv2d(NUM_FEATURES, NUM_FEATURES, kernel_size=3, stride=2, padding=1),  # 4 ‚Üí 2\n            nn.BatchNorm2d(NUM_FEATURES),\n            nn.LeakyReLU(),\n        )\n\n        self.flatten = nn.Flatten()\n        self.feature_shape = (NUM_FEATURES, IMAGE_SIZE // 16, IMAGE_SIZE // 16)\n        self.flat_dim = NUM_FEATURES * (IMAGE_SIZE // 16) ** 2\n\n        self.fc_mu = nn.Linear(self.flat_dim, z_dim)\n        self.fc_logvar = nn.Linear(self.flat_dim, z_dim)\n\n    def forward(self, x):\n        x = self.conv(x)\n        x_flat = self.flatten(x)\n        mu = self.fc_mu(x_flat)\n        logvar = self.fc_logvar(x_flat)\n        return mu, logvar"
  },
  {
    "objectID": "vae_faces.html#vae-model-wrapper-encoder-reparameterization-and-decoder",
    "href": "vae_faces.html#vae-model-wrapper-encoder-reparameterization-and-decoder",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.1 VAE Model Wrapper: Encoder, Reparameterization, and Decoder",
    "text": "1.1 VAE Model Wrapper: Encoder, Reparameterization, and Decoder\n\nclass VAE(nn.Module):\n    def __init__(self, encoder, decoder):\n        super().__init__()\n        self.encoder = encoder\n        self.decoder = decoder\n\n    def reparameterize(self, mu, logvar):\n        \"\"\"\n        z = mu + sigma * epsilon\n        where epsilon ~ N(0, I)\n        \"\"\"\n        std = torch.exp(0.5 * logvar)\n        eps = torch.randn_like(std)\n        return mu + eps * std\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass:\n        - Encode input to get mu and logvar\n        - Sample z using reparameterization trick\n        - Decode z to reconstruct image\n        \"\"\"\n        mu, logvar = self.encoder(x)\n        z = self.reparameterize(mu, logvar)\n        x_recon = self.decoder(z)\n        return x_recon, mu, logvar"
  },
  {
    "objectID": "vae_faces.html#vae-loss",
    "href": "vae_faces.html#vae-loss",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.2 VAE Loss",
    "text": "1.2 VAE Loss\n\ndef vae_loss(x, x_recon, mu, logvar, beta=BETA):\n    \"\"\"\n    VAE loss = beta * reconstruction loss (MSE) + KL divergence\n    \"\"\"\n    # Reconstruction loss (MSE)\n    recon_loss = F.mse_loss(x_recon, x, reduction='mean') * beta\n\n    # KL divergence between q(z|x) and N(0, I)\n    kl_loss = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())\n    kl_loss = kl_loss / x.size(0)  # average over batch\n\n    return recon_loss + kl_loss, recon_loss, kl_loss"
  },
  {
    "objectID": "vae_faces.html#generating-and-saving-sample-images-from-the-latent-space",
    "href": "vae_faces.html#generating-and-saving-sample-images-from-the-latent-space",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.3 Generating and Saving Sample Images from the Latent Space",
    "text": "1.3 Generating and Saving Sample Images from the Latent Space\n\nfrom torchvision.utils import save_image\nimport os\n\ndef generate_images(model, epoch, z_dim, num_img=8, path=\"./output\"):\n    \"\"\"\n    Generate and save images from random latent vectors after each epoch.\n    \"\"\"\n    os.makedirs(path, exist_ok=True)\n    model.eval()\n    z = torch.randn(num_img, z_dim).to(next(model.parameters()).device)\n    with torch.no_grad():\n        generated = model.decoder(z)\n    for i in range(num_img):\n        save_image(generated[i], f\"{path}/generated_img_{epoch:03d}_{i}.png\")"
  },
  {
    "objectID": "vae_faces.html#save-checkpoint",
    "href": "vae_faces.html#save-checkpoint",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.4 Save Checkpoint",
    "text": "1.4 Save Checkpoint\n\ndef save_checkpoint(model, epoch, loss, best_loss, path=\"./checkpoint.pt\"):\n    if loss &lt; best_loss:\n        print(f\"Saving new best model at epoch {epoch} with loss {loss:.4f}\")\n        torch.save(model.state_dict(), path)\n        return loss\n    return best_loss"
  },
  {
    "objectID": "vae_faces.html#training-step",
    "href": "vae_faces.html#training-step",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.5 Training Step",
    "text": "1.5 Training Step\n\ndef train_step(model, dataloader, optimizer, device):\n    model.train()\n    total_loss = 0\n    total_recon = 0\n    total_kl = 0\n\n    for batch in dataloader:\n        x, _ = batch if isinstance(batch, (tuple, list)) else (batch, None)\n        x = x.to(device)\n\n        optimizer.zero_grad()\n\n        x_recon, mu, logvar = model(x)\n        loss, recon_loss, kl_loss = vae_loss(x, x_recon, mu, logvar)\n        loss.backward()\n        optimizer.step()\n\n        total_loss += loss.item()\n        total_recon += recon_loss.item()\n        total_kl += kl_loss.item()\n\n    num_batches = len(dataloader)\n    return {\n        \"loss\": total_loss / num_batches,\n        \"reconstruction_loss\": total_recon / num_batches,\n        \"kl_loss\": total_kl / num_batches\n    }"
  },
  {
    "objectID": "vae_faces.html#validation-step",
    "href": "vae_faces.html#validation-step",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.6 Validation Step",
    "text": "1.6 Validation Step\n\n@torch.no_grad()\ndef validate_epoch(model, dataloader, device):\n    model.eval()\n    total_loss = 0\n    total_recon = 0\n    total_kl = 0\n\n    for batch in dataloader:\n        x, _ = batch if isinstance(batch, (tuple, list)) else (batch, None)\n        x = x.to(device)\n        x_recon, mu, logvar = model(x)\n        loss, recon_loss, kl_loss = vae_loss(x, x_recon, mu, logvar)\n        total_loss += loss.item()\n        total_recon += recon_loss.item()\n        total_kl += kl_loss.item()\n\n    num_batches = len(dataloader)\n    return {\n        \"loss\": total_loss / num_batches,\n        \"reconstruction_loss\": total_recon / num_batches,\n        \"kl_loss\": total_kl / num_batches\n    }"
  },
  {
    "objectID": "vae_faces.html#instantiate-model-optimizer-writer-device",
    "href": "vae_faces.html#instantiate-model-optimizer-writer-device",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.7 Instantiate model, optimizer, writer, device",
    "text": "1.7 Instantiate model, optimizer, writer, device\n\nfrom torch.utils.tensorboard import SummaryWriter\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\nencoder = Encoder(z_dim=Z_DIM)\ndecoder = Decoder(z_dim=Z_DIM)\nvae = VAE(encoder, decoder).to(device)\n\noptimizer = optim.Adam(vae.parameters(), lr=LEARNING_RATE)\n\nwriter = SummaryWriter(log_dir=\"./logs\")"
  },
  {
    "objectID": "vae_faces.html#training-the-vae-model",
    "href": "vae_faces.html#training-the-vae-model",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.8 Training the VAE Model",
    "text": "1.8 Training the VAE Model\n\nbest_loss = float(\"inf\")\n\nfor epoch in range(EPOCHS):\n    train_logs = train_step(vae, train_loader, optimizer, device)\n    val_logs = validate_epoch(vae, val_loader, device)\n\n    print(f\"Epoch {epoch+1:02d} | \"\n          f\"Train Loss: {train_logs['loss']:.4f} | \"\n          f\"Val Loss: {val_logs['loss']:.4f}\")\n\n    # Save best model\n    best_loss = save_checkpoint(vae, epoch, val_logs[\"loss\"], best_loss)\n\n    # Generate and save sample images\n    generate_images(vae, epoch, Z_DIM)\n\n    # Log to TensorBoard\n    writer.add_scalar(\"Loss/train\", train_logs[\"loss\"], epoch)\n    writer.add_scalar(\"Loss/val\", val_logs[\"loss\"], epoch)\n    writer.add_scalar(\"KL/train\", train_logs[\"kl_loss\"], epoch)\n    writer.add_scalar(\"Recon/train\", train_logs[\"reconstruction_loss\"], epoch)\n\nEpoch 01 | Train Loss: 72.4671 | Val Loss: 58.4050\nSaving new best model at epoch 0 with loss 58.4050"
  },
  {
    "objectID": "vae_faces.html#reconstruct-using-the-variational-autoencoder",
    "href": "vae_faces.html#reconstruct-using-the-variational-autoencoder",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.9 Reconstruct using the variational autoencoder",
    "text": "1.9 Reconstruct using the variational autoencoder\n\n# Select a batch of images from the training set\nexample_images, _ = next(iter(train_loader))  # Ignore labels\nexample_images = example_images[:8].to(device)  # Select first 8 images\n\n# Set model to evaluation mode\nvae.eval()\n\n# Forward pass through the VAE to get reconstructions\nwith torch.no_grad():\n    reconstructions, _, _ = vae(example_images)\n\n# Move tensors to CPU for display\nexample_images = example_images.cpu()\nreconstructions = reconstructions.cpu()\n\n# Display original images\nprint(\"Example real faces\")\ndisplay(example_images)\n\n# Display reconstructed images\nprint(\"Reconstructions\")\ndisplay(reconstructions)\n\nExample real faces\n\n\n\n\n\n\n\n\n\nReconstructions"
  },
  {
    "objectID": "vae_faces.html#generate-new-faces",
    "href": "vae_faces.html#generate-new-faces",
    "title": "Face Generation with Convolutional VAE",
    "section": "1.10 Generate New Faces",
    "text": "1.10 Generate New Faces\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Sample latent vectors from standard normal distribution\ngrid_width, grid_height = 10, 3\nnum_samples = grid_width * grid_height\nz_sample = torch.randn(num_samples, Z_DIM).to(device)\n\n# Decode to generate new faces\nvae.eval()\nwith torch.no_grad():\n    generated_faces = vae.decoder(z_sample).cpu()  # Shape: [N, C, H, W]\n\n# Plot grid of generated images\nfig = plt.figure(figsize=(18, 5))\nfig.subplots_adjust(hspace=0.4, wspace=0.4)\n\nfor i in range(num_samples):\n    ax = fig.add_subplot(grid_height, grid_width, i + 1)\n    ax.axis(\"off\")\n    img = generated_faces[i].permute(1, 2, 0).numpy()  # CHW ‚Üí HWC\n    ax.imshow(img)\n\nplt.suptitle(\"Generated Faces from Sampled Latent Vectors\", fontsize=16)\nplt.show()"
  },
  {
    "objectID": "vae.html",
    "href": "vae.html",
    "title": "Variational Autoencoders",
    "section": "",
    "text": "Variational Autoencoders (VAEs) combine the power of neural networks with probabilistic inference to model complex data distributions. This blog unpacks the intuition, math, and implementation of VAEs ‚Äî from KL divergence and the ELBO to PyTorch code that generates to generate new images."
  },
  {
    "objectID": "vae.html#autoencoders-vs-variational-autoencoders",
    "href": "vae.html#autoencoders-vs-variational-autoencoders",
    "title": "Variational Autoencoders",
    "section": "1 Autoencoders vs Variational Autoencoders",
    "text": "1 Autoencoders vs Variational Autoencoders\nTraditional autoencoders learn to compress data into a lower-dimensional representation (latent space) and reconstruct it. However, they fall short in several areas:\n\nThey lack generative capabilities ‚Äî they cannot sample new data effectively\nThe latent space is unstructured, offering little control or interpretation\nThere is no probabilistic modeling, limiting uncertainty estimation\n\nVariational Autoencoders (VAEs) were introduced to overcome these limitations. Rather than encoding inputs into fixed latent vectors, VAEs learn a probabilistic latent space by modeling each input as a distribution ‚Äî typically a Gaussian with a learned mean \\(\\\\mu\\) and standard deviation \\(\\\\sigma\\). This approach enables the model to sample latent variables \\(z\\) using the reparameterization trick, allowing the entire architecture to remain differentiable and trainable. By doing so, VAEs not only enable reconstruction, but also promote the learning of a continuous, interpretable latent space ‚Äî a key enabler for generation and interpolation.\nThe diagram below illustrates this process:\n\nSource: Wikimedia Commons, licensed under CC BY-SA 4.0."
  },
  {
    "objectID": "vae.html#probabilistic-framework",
    "href": "vae.html#probabilistic-framework",
    "title": "Variational Autoencoders",
    "section": "2 Probabilistic Framework",
    "text": "2 Probabilistic Framework\nMore formally, VAEs assume the data is generated by a two-step process:\n\nSample a latent variable \\(\\mathbf{z} \\sim \\mathcal{N}(0, I)\\)\nGenerate the observation \\(\\mathbf{x}\\) from: \\[\np(\\mathbf{x}|\\mathbf{z}) = \\mathcal{N}(\\mu_\\theta(\\mathbf{z}), \\Sigma_\\theta(\\mathbf{z}))\n\\] where \\(\\mu_\\theta\\) and \\(\\Sigma_\\theta\\) are neural networks parameterized by \\(\\theta\\)\n\nHere, \\(\\mathbf{z}\\) acts as a hidden or latent variable, which is unobserved during training. The model thus defines a mixture of infinitely many Gaussians ‚Äî one for each \\(\\mathbf{z}\\).\nTo compute the likelihood of a data point \\(\\mathbf{x}\\), we must marginalize over all possible latent variables: \\[\n  p(\\mathbf{x}) = \\int p(\\mathbf{x}, \\mathbf{z}) \\, d\\mathbf{z}\n  \\]\nThis integral requires integrating over all possible values of the latent variable \\(\\mathbf{z}\\), which is often high-dimensional and affects the likelihood in a non-linear way through neural networks. Because of this, computing the marginal likelihood exactly is computationally intractable. This motivates the use of techniques like variational inference and ELBO.\n\n2.1 Computational Challenge\nThis integral requires integrating over:\n\nAll possible values of \\(\\mathbf{z}\\) (often high-dimensional)\nNon-linear transformations through neural networks\n\nResult: Exact computation is intractable, motivating techniques like variational inference and ELBO (developed next)."
  },
  {
    "objectID": "vae.html#estimating-the-marginal-likelihood",
    "href": "vae.html#estimating-the-marginal-likelihood",
    "title": "Variational Autoencoders",
    "section": "3 Estimating the Marginal Likelihood",
    "text": "3 Estimating the Marginal Likelihood\n\n3.1 Naive Monte Carlo Estimation\nOne natural idea is to approximate the integral using samples from a simple distribution like the uniform distribution:\n\\[\np(x) \\approx \\frac{1}{K} \\sum_{j=1}^K p_\\theta(x, z_j), \\quad z_j \\sim \\text{Uniform}\n\\]\nHowever, this fails in practice. For most values of \\(z\\), the joint probability \\(p_\\theta(x, z)\\) is very low. Only a small region of the latent space contributes significantly to the integral. Since uniform sampling does not concentrate around these regions, the estimator has high variance and rarely ‚Äúhits‚Äù likely values of \\(z\\).\n\n\n3.2 Importance Sampling\nTo address this, we use importance sampling, introducing a proposal distribution \\(q(z)\\):\n\\[\np(x) = \\mathbb{E}_{q(z)} \\left[ \\frac{p_\\theta(x, z)}{q(z)} \\right]\n\\]\nThis gives an unbiased estimator of \\(p(x)\\) if \\(q(z)\\) is well-chosen (ideally close to \\(p_\\theta(z|x)\\)). Intuitively, we sample \\(z\\) more frequently in regions where \\(p_\\theta(x, z)\\) is high.\n\n\n\n3.3 Log likelihood\nOur goal is to optimize the log-likelihood, and the log of an expectation is not the same as the expectation of the log. That is,\n\\[\n\\log p(x) = log \\mathbb{E}_{q(z)} \\left[ \\frac{p_\\theta(x, z)}{q(z)} \\right] \\neq \\mathbb{E}_{q(z)} \\left[ \\log \\frac{p_\\theta(x, z)}{q(z)} \\right]\n\\]\nWhile the marginal likelihood p(x) can be estimated unbiasedly using importance sampling, estimating its logarithm \\(p(x)\\) introduces bias due to the concavity of the log function. This is captured by Jensen‚Äôs Inequality, which tells us:\n\\[\n\\log \\mathbb{E}_{q(z)} \\left[ \\frac{p_\\theta(x, z)}{q(z)} \\right] \\geq \\underbrace{\\mathbb{E}_{q(z)} \\left[ \\log \\frac{p_\\theta(x, z)}{q(z)} \\right]}_{\\text{ELBO}}\n\\]\nThis means that the expected log of the estimator underestimates the true log-likelihood. The right-hand side provides a tractable surrogate objective known as the Evidence Lower Bound (ELBO), which is a biased lower bound to \\(\\log p(x)\\). Optimizing the ELBO allows us to indirectly maximize the intractable log-likelihood.\nIn the next section, we formally derive this bound and explore its components in detail."
  },
  {
    "objectID": "vae.html#why-variational-inference",
    "href": "vae.html#why-variational-inference",
    "title": "Variational Autoencoders",
    "section": "4 Why Variational Inference?",
    "text": "4 Why Variational Inference?\nComputing the true posterior distribution \\(p(z \\mid x)\\) is intractable in most cases, because it requires evaluating the marginal likelihood \\(p(x)\\), which involves integrating over all possible values of \\(z\\):\n\\[\np(x) = \\int p(x, z) \\, dz\n\\]\nVariational inference tackles this by introducing a tractable, parameterized distribution \\(q(z)\\) to approximate \\(p(z|x)\\). We aim to make \\(q(z)\\) as close as possible to the true posterior by minimizing the KL divergence:\n\\[\nD_{\\text{KL}}(q(z) \\| p(z|x))\n\\]\nThis turns inference into an optimization problem. A key result is the Evidence Lower Bound (ELBO). See next section."
  },
  {
    "objectID": "vae.html#training-a-vae",
    "href": "vae.html#training-a-vae",
    "title": "Variational Autoencoders",
    "section": "5 Training a VAE",
    "text": "5 Training a VAE\n\n5.1 ELBO Objective\nNow that we‚Äôve introduced the challenge of approximating the intractable posterior using variational inference, we turn our attention to deriving the Evidence Lower Bound (ELBO). This derivation reveals how optimizing a surrogate objective allows us to approximate the true log-likelihood of the data while keeping the approximate posterior close to the prior. The steps below walk through this formulation.\n\n5.1.1 KL Divergence Objective\n\\[\\begin{equation}\nD_{KL}(q(z)\\|p(z|x; \\theta)) = \\sum_z q(z) \\log \\frac{q(z)}{p(z|x; \\theta)}\n\\end{equation}\\]\n\n\n5.1.2 Apply Bayes‚Äô Rule\nSubstitute \\(p(z|x; \\theta) = \\frac{p(z,x;\\theta)}{p(x;\\theta)}\\): \\[\\begin{equation}\n= \\sum_z q(z) \\log \\left( \\frac{q(z) \\cdot p(x; \\theta)}{p(z, x; \\theta)} \\right)\n\\end{equation}\\]\n\n\n5.1.3 Decompose Terms\n\\[\\begin{align}\n&= \\sum_z q(z) \\log q(z) + \\sum_z q(z) \\log p(x; \\theta) \\nonumber \\\\\n&\\quad - \\sum_z q(z) \\log p(z, x; \\theta) \\\\\n&= -H(q) + \\log p(x; \\theta) - \\mathbb{E}_q[\\log p(z,x;\\theta)]\n\\end{align}\\]\n\nNote: The term \\(\\mathcal{H}(q)\\) represents the entropy of the variational distribution \\(q(z|x)\\). Entropy is defined as:\n\\[\n\\mathcal{H}(q) = -\\sum_z q(z) \\log q(z) = -\\mathbb{E}_{q(z)}[\\log q(z)]\n\\]\nEntropy measures the amount of uncertainty or ‚Äúspread‚Äù in a distribution. A high-entropy \\(q(z)\\) places probability mass across a wide region of the latent space, while a low-entropy \\(q(z)\\) is more concentrated. This decomposition is key to understanding the KL divergence term in the ELBO.\n\n\n\n5.1.4 Rearrange for ELBO\n\\[\n\\log p(x; \\theta) =\n\\underbrace{\n    \\mathbb{E}_q[\\log p(z, x; \\theta)] + \\mathcal{H}(q)\n}_{\\text{ELBO}}\n+D_{KL}(q(z)\\|p(z|x; \\theta))\n\\]\nThis equation shows that the log-likelihood \\(\\log p(x)\\) can be decomposed into the ELBO and the KL divergence between the approximate posterior and the true posterior. Since the KL divergence is always non-negative, the ELBO serves as a lower bound to the log-likelihood. By maximizing the ELBO, we indirectly minimize the KL divergence, bringing \\(q(z)\\) closer to \\(p(z|x)\\).\n Visualizing how \\(\\log p(x)\\) decomposes into the ELBO and KL divergence.\nSource: deepgenerativemodels.github.io\n\n\n5.1.5 Key Results\n\nEvidence Lower Bound (ELBO): \\[\\begin{equation}\n\\mathcal{L}(\\theta,\\phi) = \\mathbb{E}_{q(z;\\phi)}[\\log p(x,z;\\theta)] + H(q(z;\\phi))\n\\end{equation}\\]\nOptimization: \\[\\begin{equation}\n\\max_{\\theta,\\phi} \\mathcal{L}(\\theta,\\phi) \\Rightarrow\n\\begin{cases}\n\\text{Maximizes data likelihood} \\\\\n\\text{Minimizes } D_{KL}(q\\|p)\n\\end{cases}\n\\end{equation}\\]"
  },
  {
    "objectID": "vae.html#understanding-the-kl-divergence-term-in-the-vae-loss",
    "href": "vae.html#understanding-the-kl-divergence-term-in-the-vae-loss",
    "title": "Variational Autoencoders",
    "section": "6 Understanding the KL Divergence Term in the VAE Loss",
    "text": "6 Understanding the KL Divergence Term in the VAE Loss\nIn a VAE, the KL divergence term penalizes the encoder for producing latent distributions that deviate too far from the standard normal prior. This regularization has several important benefits:\n\nIt ensures that the latent space has a consistent structure, enabling meaningful sampling and interpolation.\nIt helps avoid large gaps between clusters in latent space by encouraging the encoder to distribute representations more uniformly.\nIt pushes the model to use the space around the origin more symmetrically and efficiently.\n\n\n6.1 Balancing KL Divergence and Reconstruction\nIn a Variational Autoencoder, the loss balances two goals:\n\nReconstruction ‚Äî making the output resemble the input\nRegularization ‚Äî keeping the latent space close to a standard normal distribution\n\nThis is captured by the loss function:\n\\[\n\\mathcal{L}_{\\text{VAE}} = \\text{Reconstruction Loss} + \\beta \\cdot D_{\\text{KL}}(q(z|x) \\,\\|\\, p(z))\n\\]\nThe parameter \\(\\beta\\) controls how strongly we enforce this regularization. Getting its value right is critical.\n\n6.1.1 When \\(\\beta\\) is too low:\n\nThe model mostly ignores the KL term, behaving like a plain autoencoder\nThe latent space becomes disorganized or fragmented\nSampling from the prior \\(p(z) = \\mathcal{N}(0, I)\\) results in unrealistic or broken outputs\n\n\n\n6.1.2 When \\(\\beta\\) is too high:\n\nThe encoder is forced to keep \\(q(z|x)\\) too close to the prior\nIt encodes less information about the input\nReconstructions become blurry or generic, since the decoder gets little to work with\n\n\nChoosing \\(\\beta\\) carefully is essential for balancing generalization and fidelity.\nA well-tuned \\(\\beta\\) helps the VAE both reconstruct accurately and generate new samples that resemble the training data.\n\n\n\n\n6.2 Gradient Challenge\nIn variational inference, we approximate the true posterior \\(p(z|x)\\) with a tractable distribution \\(q_\\phi(z)\\). This allows us to optimize the ELBO:\n\\[\n\\mathcal{L}(x; \\theta, \\phi) = \\mathbb{E}_{q(z; \\phi)} \\left[ \\log p(z, x; \\theta) - \\log q(z; \\phi) \\right]\n\\]\nOur goal is to maximize this objective with respect to both \\(\\theta\\) and \\(\\phi\\). While computing the gradient with respect to \\(\\theta\\) is straightforward, optimizing with respect to \\(\\phi\\) presents a challenge.\nThe complication arises because \\(\\phi\\) appears both in the density \\(q_\\phi(z|x)\\) and in the expectation operator. That is:\n\\[\n\\nabla_\\phi \\mathbb{E}_{q(z; \\phi)} \\left[ \\log p(z, x; \\theta) - \\log q(z; \\phi) \\right]\n\\]\nThis gradient is hard to compute directly because we‚Äôre sampling from a distribution that depends on the parameters we‚Äôre trying to update.\n\n\n\n6.3 The Reparameterization Trick\nTo make this expression differentiable, we reparameterize the random variable \\(z\\) as a deterministic transformation of a parameter-free noise variable \\(\\epsilon\\):\n\\[\n\\epsilon \\sim \\mathcal{N}(0, I), \\quad z = \\mu_\\phi(x) + \\sigma_\\phi(x) \\cdot \\epsilon\n\\]\nThis turns the expectation into:\n\\[\n\\mathbb{E}_{\\epsilon \\sim \\mathcal{N}(0, I)}\\left[ \\log p(z, x; \\theta) - \\log q(z; \\phi) \\right]\n\\]\nwhere \\(z\\) is now a differentiable function of \\(\\phi\\).\n\n\n\nReparameterization Trick Diagram\n\n\nImage source: Wikipedia (CC BY-SA 4.0)\nThis diagram illustrates how the reparameterization trick enables differentiable sampling:\n\nIn the original formulation, \\(z\\) is sampled directly from a learned distribution, breaking the gradient flow.\nIn the reparameterized formulation, we sample noise \\(\\epsilon \\sim \\mathcal{N}(0, I)\\), and compute \\(z = \\mu + \\sigma \\cdot \\epsilon\\), making the sampling path fully differentiable.\n\n\n6.3.1 Monte Carlo Approximation\nWe approximate the expectation using Monte Carlo sampling:\n\\[\n\\mathbb{E}_{\\epsilon}[\\log p_\\theta(x, z) - \\log q_\\phi(z)] \\approx \\frac{1}{K} \\sum_{k=1}^K \\left[\\log p_\\theta(x, z^{(k)}) - \\log q_\\phi(z^{(k)})\\right]\n\\]\nwith:\n\\[\nz^{(k)} = \\mu_\\phi(x) + \\sigma_\\phi(x) \\cdot \\epsilon^{(k)}, \\quad \\epsilon^{(k)} \\sim \\mathcal{N}(0, I)\n\\]\nThis enables us to compute gradients using backpropagation.\n\n\n\n6.3.2 Summary\n\nVariational inference introduces a gradient challenge because \\(q_\\phi(z)\\) depends on \\(\\phi\\)\nThe reparameterization trick expresses \\(z\\) as a differentiable function of noise and \\(\\phi\\)\nThis allows us to use backpropagation to optimize the ELBO efficiently\n\n\n\n\n\n6.4 Amortized Inference\nIn classical variational inference, we introduce a separate set of variational parameters \\(\\phi^i\\) for each datapoint \\(x^i\\) to approximate the true posterior \\(p(z|x^i)\\). However:\n\nOptimizing a separate \\(\\phi^i\\) for every datapoint is computationally expensive and does not scale to large datasets.\n\n\n\n6.4.1 The Key Idea: Amortization\nInstead of learning and storing a separate \\(\\phi^i\\) for every datapoint, we learn a single parametric function \\(f_\\phi(x)\\) ‚Äî typically a neural network ‚Äî that maps each input \\(x\\) to the parameters of the approximate posterior:\n\\[\nq_\\phi(z|x) = \\mathcal{N}\\left(\\mu_\\phi(x), \\sigma^2_\\phi(x)\\right)\n\\]\nHere, \\(\\phi\\) are the shared parameters of the encoder network, and \\(\\mu_\\phi(x), \\sigma_\\phi(x)\\) are its outputs.\nThis is like learning a regression function that predicts the optimal variational parameters for any input \\(x\\).\n\n\n\n\n6.5 Training with Amortized Inference\nOur training objective remains the ELBO:\n\\[\n\\mathcal{L}(x; \\theta, \\phi) = \\mathbb{E}_{q_\\phi(z|x)}\\left[\\log p_\\theta(x, z) - \\log q_\\phi(z|x)\\right]\n\\]\nWe optimize both \\(\\theta\\) (decoder parameters) and \\(\\phi\\) (encoder parameters) using stochastic gradient descent.\n\n6.5.1 Algorithm:\n\nInitialize \\(\\theta^{(0)}, \\phi^{(0)}\\)\nSample a datapoint \\(x^i\\)\nUse \\(f_\\phi(x^i)\\) to produce \\(\\mu^i, \\sigma^i\\)\nSample \\(z^i = \\mu^i + \\sigma^i \\cdot \\epsilon\\), with \\(\\epsilon \\sim \\mathcal{N}(0, I)\\)\nEstimate the ELBO and compute gradients w.r.t. \\(\\theta, \\phi\\)\nUpdate \\(\\theta, \\phi\\) using gradient descent\nUpdate \\(\\theta\\), \\(\\phi\\) using gradient descent:\n\n\\[\n\\phi \\leftarrow \\phi + \\tilde{\\nabla}_\\phi \\sum_{x \\in \\mathcal{B}} \\text{ELBO}(x; \\theta, \\phi)\n\\]\n\\[\n\\theta \\leftarrow \\theta + \\tilde{\\nabla}_\\theta \\sum_{x \\in \\mathcal{B}} \\text{ELBO}(x; \\theta, \\phi)\n\\]\nwhere \\(\\mathcal{B}\\) is the current minibatch and \\(\\tilde{\\nabla}\\) indicates a stochastic gradient approximation.\n\n\n\n\n6.6 Summary\n\nAmortized inference replaces per-datapoint optimization with a single learned mapping \\(f_\\phi(x)\\)\nThis makes variational inference scalable and efficient\nThe model can generalize to unseen inputs by predicting variational parameters on-the-fly\n\n\nNote: Following common practice in the literature, we use \\(\\phi\\) to denote the parameters of the encoder network, even though it now defines a function rather than individual variational parameters."
  },
  {
    "objectID": "vae.html#applications-of-vaes",
    "href": "vae.html#applications-of-vaes",
    "title": "Variational Autoencoders",
    "section": "7 Applications of VAEs",
    "text": "7 Applications of VAEs\nVariational Autoencoders are widely used in:\n\nImage Generation: VAEs can generate new images similar to the training data (e.g., MNIST digits)\n\nAnomaly Detection: High reconstruction error flags unusual data points\n\nRepresentation Learning: Latent space captures features for downstream tasks\n\n\n7.1 üòé Face Generation with Convolutional VAE\nTo complement the theory, I‚Äôve built a full PyTorch implementation of a Variational Autoencoder trained on the CelebA dataset.\nüìò The notebook walks through:\n\nDefining the encoder, decoder, and reparameterization trick\n\nImplementing the ELBO loss function (reconstruction + KL divergence)\n\nTraining the model on face images\n\nGenerating new faces from random latent vectors\n\n\nüìì View on GitHub"
  },
  {
    "objectID": "vae.html#this-example-is-designed-to-reinforce-the-theoretical-concepts-from-earlier-sections.",
    "href": "vae.html#this-example-is-designed-to-reinforce-the-theoretical-concepts-from-earlier-sections.",
    "title": "Variational Autoencoders",
    "section": "8 This example is designed to reinforce the theoretical concepts from earlier sections.",
    "text": "8 This example is designed to reinforce the theoretical concepts from earlier sections."
  },
  {
    "objectID": "vae.html#further-reading",
    "href": "vae.html#further-reading",
    "title": "Variational Autoencoders",
    "section": "9 Further Reading",
    "text": "9 Further Reading\nFor readers interested in diving deeper into the theory and applications of variational autoencoders, the following resources are recommended:\n\nTutorial on Variational Autoencoders\nCarl Doersch (2016)\nhttps://arxiv.org/pdf/1606.05908\nAuto-Encoding Variational Bayes\nKingma & Welling (2014) ‚Äî the original VAE paper\nhttps://arxiv.org/pdf/1312.6114\nThe Challenges of Amortized Inference for Structured Prediction\nCremer, Li, & Duvenaud (2019)\nhttps://arxiv.org/pdf/1906.02691\nDeep Generative Models course notes\nhttps://deepgenerativemodels.github.io/notes/vae/"
  },
  {
    "objectID": "coming-soon.html",
    "href": "coming-soon.html",
    "title": "Coming Soon",
    "section": "",
    "text": "This page is under construction and will be available soon. Stay tuned!"
  },
  {
    "objectID": "diffusion.html",
    "href": "diffusion.html",
    "title": "Diffusion Models",
    "section": "",
    "text": "Diffusion models are a powerful class of generative models that learn to create data‚Äîsuch as images‚Äîby reversing a gradual noising process. During training, real data is progressively corrupted by adding small amounts of Gaussian noise over many steps until it becomes nearly indistinguishable from pure noise. A neural network is then trained to learn the reverse process: transforming noise back into realistic samples, one step at a time.\n\n\n\nDiffusion models start by gradually adding noise to real data, then learn to reverse this process step by step to generate realistic samples.\n\n\nAdapted from the CVPR 2023 Tutorial on Diffusion Models by Arash Vahdat.\nThis approach has enabled state-of-the-art results in image generation, powering tools like DALL¬∑E 2, Imagen, and Stable Diffusion. One of the key advantages of diffusion models lies in their training stability and output quality, especially when compared to earlier generative approaches:\n\nGANs generate sharp images but rely on adversarial training, which can be unstable and prone to mode collapse.\nVAEs are more stable but often produce blurry outputs due to their reliance on Gaussian assumptions and variational approximations.\nNormalizing Flows provide exact log-likelihoods and stable training but require invertible architectures, which limit model expressiveness.\nDiffusion models avoid adversarial dynamics and use a simple denoising objective. This makes them easier to train and capable of producing highly detailed and diverse samples.\n\nThis combination of theoretical simplicity, training robustness, and high-quality outputs has made diffusion models one of the most effective generative modeling techniques in use today.\n\n\nDiffusion models may seem very different from VAEs at first glance, but they share a surprising number of structural similarities. Both involve a forward process that adds noise and a reverse process that reconstructs data. And both optimize a form of the ELBO ‚Äî though with very different interpretations.\n\n\n\nVisual comparison of latent structure in VAEs vs.¬†Diffusion Models.\n\n\nThe table below highlights key conceptual parallels:\n\n\n\n\n\n\n\n\nAspect\nVAEs\nDiffusion Models\n\n\n\n\nForward process\nLearned encoder \\(q_\\phi(z \\mid x)\\)\nFixed noising process \\(q(x_t \\mid x_{t-1})\\)\n\n\nReverse process\nLearned decoder \\(p_\\theta(x \\mid z)\\)\nLearned denoising model \\(p_\\theta(x_{t-1} \\mid x_t)\\)\n\n\nLatent space\nExplicit latent variable \\(z\\)\nNo explicit latent; \\(x_t\\) acts as noisy latent\n\n\nTraining objective\nMaximize ELBO over \\(z\\)\nMaximize ELBO via simplified KL terms and noise prediction\n\n\n\n\n\n\nDiffusion models have rapidly moved from research labs to real-world applications. Today, they power many state-of-the-art generative tools:\n\n\n\nDALL¬∑E 2 (OpenAI): Generates realistic images from text prompts.\nImagen (Google): Leverages powerful language encoders for high-fidelity image synthesis.\n\n\n\n\n\nMake-A-Video (Meta): Extends image models to video generation using textual input.\nImagen Video (Google): Builds on Imagen to generate coherent video sequences.\n\n\n\n\n\nDreamFusion (Google): Produces 3D scenes from text by combining diffusion with 3D rendering techniques.\n\nThese use cases highlight why diffusion models are considered one of the most promising families of generative models today. The rest of this guide will unpack how they work, step by step.\nTo understand how these systems operate, we‚Äôll first explore the mathematical core of diffusion models."
  },
  {
    "objectID": "diffusion.html#introduction",
    "href": "diffusion.html#introduction",
    "title": "Diffusion Models",
    "section": "",
    "text": "Diffusion models are a powerful class of generative models that learn to create data‚Äîsuch as images‚Äîby reversing a gradual noising process. During training, real data is progressively corrupted by adding small amounts of Gaussian noise over many steps until it becomes nearly indistinguishable from pure noise. A neural network is then trained to learn the reverse process: transforming noise back into realistic samples, one step at a time.\n\n\n\nDiffusion models start by gradually adding noise to real data, then learn to reverse this process step by step to generate realistic samples.\n\n\nAdapted from the CVPR 2023 Tutorial on Diffusion Models by Arash Vahdat.\nThis approach has enabled state-of-the-art results in image generation, powering tools like DALL¬∑E 2, Imagen, and Stable Diffusion. One of the key advantages of diffusion models lies in their training stability and output quality, especially when compared to earlier generative approaches:\n\nGANs generate sharp images but rely on adversarial training, which can be unstable and prone to mode collapse.\nVAEs are more stable but often produce blurry outputs due to their reliance on Gaussian assumptions and variational approximations.\nNormalizing Flows provide exact log-likelihoods and stable training but require invertible architectures, which limit model expressiveness.\nDiffusion models avoid adversarial dynamics and use a simple denoising objective. This makes them easier to train and capable of producing highly detailed and diverse samples.\n\nThis combination of theoretical simplicity, training robustness, and high-quality outputs has made diffusion models one of the most effective generative modeling techniques in use today.\n\n\nDiffusion models may seem very different from VAEs at first glance, but they share a surprising number of structural similarities. Both involve a forward process that adds noise and a reverse process that reconstructs data. And both optimize a form of the ELBO ‚Äî though with very different interpretations.\n\n\n\nVisual comparison of latent structure in VAEs vs.¬†Diffusion Models.\n\n\nThe table below highlights key conceptual parallels:\n\n\n\n\n\n\n\n\nAspect\nVAEs\nDiffusion Models\n\n\n\n\nForward process\nLearned encoder \\(q_\\phi(z \\mid x)\\)\nFixed noising process \\(q(x_t \\mid x_{t-1})\\)\n\n\nReverse process\nLearned decoder \\(p_\\theta(x \\mid z)\\)\nLearned denoising model \\(p_\\theta(x_{t-1} \\mid x_t)\\)\n\n\nLatent space\nExplicit latent variable \\(z\\)\nNo explicit latent; \\(x_t\\) acts as noisy latent\n\n\nTraining objective\nMaximize ELBO over \\(z\\)\nMaximize ELBO via simplified KL terms and noise prediction\n\n\n\n\n\n\nDiffusion models have rapidly moved from research labs to real-world applications. Today, they power many state-of-the-art generative tools:\n\n\n\nDALL¬∑E 2 (OpenAI): Generates realistic images from text prompts.\nImagen (Google): Leverages powerful language encoders for high-fidelity image synthesis.\n\n\n\n\n\nMake-A-Video (Meta): Extends image models to video generation using textual input.\nImagen Video (Google): Builds on Imagen to generate coherent video sequences.\n\n\n\n\n\nDreamFusion (Google): Produces 3D scenes from text by combining diffusion with 3D rendering techniques.\n\nThese use cases highlight why diffusion models are considered one of the most promising families of generative models today. The rest of this guide will unpack how they work, step by step.\nTo understand how these systems operate, we‚Äôll first explore the mathematical core of diffusion models."
  },
  {
    "objectID": "diffusion.html#forward-diffusion-process",
    "href": "diffusion.html#forward-diffusion-process",
    "title": "Diffusion Models",
    "section": "2 Forward Diffusion Process",
    "text": "2 Forward Diffusion Process\nThe forward diffusion process gradually turns a data sample (such as an image) into pure noise by adding a little bit of random noise at each step. This process is a Markov chain, meaning each step depends only on the previous one.\n\n2.1 Start with a Data Sample\nBegin with a data point \\(x_0\\), sampled from dataset (such as a real image). The goal is to slowly corrupt \\(x_0\\) by adding noise over many steps, until it becomes indistinguishable from random Gaussian noise.\nWe‚Äôll later see that it‚Äôs also possible to sample \\(x_t\\) directly from \\(x_0\\), without simulating every step.\n\n\n2.2 Add Noise Recursively\nTo model the forward noising process, we define a noise schedule \\(\\{\\beta_1, \\dots, \\beta_T\\}\\), where each \\(\\beta_t \\in (0, 1)\\) controls how much Gaussian noise is added at step \\(t\\).\nThis gives the following transition distribution:\n\\[\nq(x_t \\mid x_{t-1}) = \\mathcal{N}\\left(\\sqrt{1 - \\beta_t} \\, x_{t-1}, \\, \\beta_t \\mathbf{I} \\right)\n\\]\nTo simplify notation, we define: \\[\n\\alpha_t = 1 - \\beta_t, \\quad \\bar{\\alpha}_t = \\prod_{i=1}^t \\alpha_i\n\\]\nHere, \\(\\alpha_t\\) represents the amount of signal preserved at each step, and \\(\\bar{\\alpha}_t\\) gives the cumulative signal retention over \\(t\\) steps.\nThen, at each time step \\(t\\), the forward process is defined as: \\[\nq(x_t \\mid x_{t-1}) = \\mathcal{N} \\left( x_t ; \\sqrt{\\alpha_t} x_{t-1}, (1 - \\alpha_t) I \\right)\n\\]\nWhere:\n\n\\(\\alpha_t = 1 - \\beta_t\\), with \\(\\beta_t\\) a small positive number controlling the noise level.\n\nThe variance term \\((1 - \\alpha_t) I = \\beta_t I\\) controls how much noise is added at each step.\n\n\\(I\\) is the identity matrix, so noise is added independently to each pixel or component.\n\n\nIntuition: At each step, we shrink the signal and add new Gaussian noise. Over many steps, the data becomes increasingly noisy and eventually indistinguishable from pure noise.\n\n\n\n\nForward diffusion process: gradually adds Gaussian noise to the input image across \\(T\\) steps.\n\n\nAdapted from the CVPR 2023 Tutorial on Diffusion Models by Arash Vahdat.\n\n\n\n\n\n\nWhy keep \\(\\beta_t\\) small?\n\n\n\nKeeping \\(\\beta_t\\) small ensures that noise is added gradually. This allows the model to retain structure across many steps and converge slowly to pure noise. Large values of \\(\\beta_t\\) would destroy the signal too quickly, making it harder for the reverse model to reconstruct the data. The design of the forward process balances signal decay (via \\(\\sqrt{\\alpha_t}\\)) and noise growth (via \\(\\sqrt{1 - \\alpha_t}\\)) to ensure a smooth, learnable transition.\n\n\n\n\n\nComparison of signal (\\(\\bar{\\alpha}_t\\)) and noise (\\(1 - \\bar{\\alpha}_t\\)) schedules for linear and cosine noise schedules. Cosine adds noise more gradually early on, improving training stability and sample quality.\n\n\nBy chaining these noise steps over time, we define a forward Markov process that gradually transforms \\(x_0\\) into pure noise \\(x_T\\).\n\n\n2.3 The Markov Chain\nThe full sequence is:\n\\[\nx_0 \\rightarrow x_1 \\rightarrow x_2 \\rightarrow \\ldots \\rightarrow x_T\n\\]\nThe joint probability of the sequence is:\n\\[\nq(x_{1:T} \\mid x_0) = \\prod_{t=1}^{T} q(x_t \\mid x_{t-1})\n\\]\nThis means we can sample the whole chain by repeatedly applying the noise step.\n\n\n\n\n\n\nWhy it‚Äôs still useful to model the full chain\n\n\n\nInsight: While the forward process defines a full Markov chain from \\(x_0\\) to \\(x_T\\), we‚Äôll soon see that it‚Äôs also possible to sample any \\(x_t\\) directly from \\(x_0\\) using a closed-form Gaussian ‚Äî without simulating each intermediate step.\n\n\n\n\n2.4 Deriving the Marginal Distribution \\(q(x_t \\mid x_0)\\)\n How do we get the formula that lets us sample \\(x_t\\) directly from \\(x_0\\) (without simulating all the intermediate steps)?\n\nLet‚Äôs see how \\(x_t\\) is built up from \\(x_0\\):\nFor \\(t = 1\\): \\[\nx_1 = \\sqrt{\\alpha_1} x_0 + \\sqrt{1 - \\alpha_1} \\epsilon_1, \\qquad \\epsilon_1 \\sim \\mathcal{N}(0, I)\n\\]\nFor \\(t = 2\\): \\[\nx_2 = \\sqrt{\\alpha_2} x_1 + \\sqrt{1 - \\alpha_2} \\epsilon_2\n\\] Substitute \\(x_1\\): \\[\nx_2 = \\sqrt{\\alpha_2} \\left( \\sqrt{\\alpha_1} x_0 + \\sqrt{1 - \\alpha_1} \\epsilon_1 \\right) + \\sqrt{1 - \\alpha_2} \\epsilon_2\n\\] \\[\n= \\sqrt{\\alpha_2 \\alpha_1} x_0 + \\sqrt{\\alpha_2 (1 - \\alpha_1)} \\epsilon_1 + \\sqrt{1 - \\alpha_2} \\epsilon_2\n\\]\nFor general \\(t\\), recursively expanding gives: \\[\nx_t = \\sqrt{\\bar{\\alpha}_t} x_0 + \\sum_{i=1}^t \\left( \\sqrt{ \\left( \\prod_{j=i+1}^t \\alpha_j \\right) (1 - \\alpha_i) } \\, \\epsilon_i \\right)\n\\] where \\(\\bar{\\alpha}_t = \\prod_{i=1}^t \\alpha_i\\).\nEach \\(\\epsilon_i\\) is independent Gaussian noise. The sum of independent Gaussians (each scaled by a constant) is still a Gaussian, with variance equal to the sum of the variances: \\[\n\\text{Total variance} = \\sum_{i=1}^t \\left( \\prod_{j=i+1}^t \\alpha_j \\right) (1 - \\alpha_i)\n\\] This sum simplifies to: \\[\n1 - \\bar{\\alpha}_t\n\\]\nThis can be proved by induction or by telescoping the sum.\nAll the little bits of noise added at each step combine into one big Gaussian noise term, with variance \\(1 - \\bar{\\alpha}_t\\).\n\n\n2.5 The Final Marginal Distribution\nSo, we can sample \\(x_t\\) directly from \\(x_0\\) using: \\[\nx_t = \\sqrt{\\bar{\\alpha}_t} x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\epsilon, \\qquad \\epsilon \\sim \\mathcal{N}(0, I)\n\\]\nThis lets us sample \\(x_t\\) directly from \\(x_0\\), without recursively computing all previous steps \\(x_1, x_2, \\dots, x_{t-1}\\).\nThis means: \\[\nq(x_t \\mid x_0) = \\mathcal{N}\\left(x_t; \\sqrt{\\bar{\\alpha}_t} x_0, (1 - \\bar{\\alpha}_t) I\\right)\n\\]\nAs \\(t\\) increases, \\(\\bar{\\alpha}_t\\) shrinks toward zero. Eventually, \\(x_t\\) becomes pure noise:\n\\[\nx_T \\sim \\mathcal{N}(0, I)\n\\]\n\n\n\nInstead of simulating each step recursively, we can directly compute \\(x_t\\) from \\(x_0\\) using the closed-form expression.\n\n\nAdapted from the CVPR 2023 Tutorial on Diffusion Models by Arash Vahdat.\n\n\n2.6 Recap: Forward Diffusion Steps\n\n\n\n\n\n\n\n\nStep\nFormula\nExplanation\n\n\n\n\n1\n\\(x_0\\)\nOriginal data sample\n\n\n2\n\\(q(x_t \\mid x_{t-1}) = \\mathcal{N}(\\sqrt{\\alpha_t} x_{t-1}, (1-\\alpha_t) I)\\)\nAdd noise at each step\n\n\n3\n\\(x_t = \\sqrt{\\bar{\\alpha}_t} x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon\\)\nDirectly sample \\(x_t\\) from \\(x_0\\) using noise \\(\\epsilon\\)\n\n\n4\n\\(q(x_t \\mid x_0) = \\mathcal{N}(\\sqrt{\\bar{\\alpha}_t} x_0, (1-\\bar{\\alpha}_t) I)\\)\nMarginal distribution at step \\(t\\)\n\n\n5\n\\(x_T \\sim \\mathcal{N}(0, I)\\)\nAfter many steps, pure noise\n\n\n\n\n\n2.7 Key Takeaways\n\nThe forward diffusion process is just repeatedly adding noise to your data.\nThanks to properties of Gaussian noise, you can describe the result as the original data scaled down plus one cumulative chunk of Gaussian noise.\n\nAfter enough steps, the data becomes indistinguishable from random noise."
  },
  {
    "objectID": "diffusion.html#reverse-diffusion-process",
    "href": "diffusion.html#reverse-diffusion-process",
    "title": "Diffusion Models",
    "section": "3 Reverse Diffusion Process",
    "text": "3 Reverse Diffusion Process\nLet‚Äôs break down the reverse diffusion process step by step. This is the generative phase of diffusion models, where we learn to turn pure noise back into data. For clarity, we‚Äôll use the same notation as in the forward process:\n\nForward process: Gradually adds noise to data via \\(q(x_t \\mid x_{t-1})\\)\nReverse process: Gradually removes noise via \\(p_\\theta(x_{t-1} \\mid x_t)\\), learned by a neural network\n\n\n\n\nReverse process: a neural network learns to iteratively denoise samples from \\(x_T\\) back to \\(x_0\\).\n\n\nAdapted from the CVPR 2023 Tutorial on Diffusion Models by Arash Vahdat.\nThe Goal of the Reverse Process\nObjective: Given a noisy sample \\(x_t\\), we want to estimate the conditional distribution \\(q(x_{t-1} \\mid x_t)\\). However, this is intractable because it would require knowing the true data distribution.\nInstead, we train a neural network to approximate it: \\[\np_\\theta(x_{t-1} \\mid x_t) = \\mathcal{N}(x_{t-1}; \\mu_\\theta(x_t, t), \\Sigma_\\theta(x_t, t))\n\\]\nHere, \\(\\mu_\\theta(x_t, t)\\) is the predicted mean and \\(\\Sigma_\\theta(x_t, t)\\) is the predicted covariance (often diagonal) of the reverse Gaussian distribution. In many implementations, the variance \\(\\Sigma_\\theta(x_t, t)\\) is either fixed or parameterized separately, so the model focuses on learning the mean \\(\\mu_\\theta(x_t, t)\\) during training.\nIn practice, many diffusion models do not directly predict \\(\\mu_\\theta\\) or \\(x_0\\), but instead predict the noise \\(\\epsilon\\) added in the forward process. This makes the objective simpler and more effective, as we‚Äôll see in the next section.\nKey Insight from the Forward Process\nIf the noise added in the forward process is small (i.e., \\(\\beta_t \\ll 1\\)), then the reverse conditional \\(q(x_{t-1} \\mid x_t)\\) is also Gaussian: \\[\nq(x_{t-1} \\mid x_t) \\approx \\mathcal{N}(x_{t-1}; \\tilde{\\mu}_t(x_t), \\tilde{\\beta}_t I)\n\\]\nThis approximation works because the forward process adds Gaussian noise in small increments at each step. The Markov chain formed by these small Gaussian transitions ensures that local conditionals (like \\(q(x_{t-1} \\mid x_t)\\)) remain Gaussian under mild assumptions.\n\n\n\n\n\n\nGlossary of Symbols\n\n\n\n\n\\(\\alpha_t\\): Variance-preserving noise coefficient at step \\(t\\)\n\\(\\bar{\\alpha}_t\\): Cumulative product of \\(\\alpha_t\\), i.e., \\(\\bar{\\alpha}_t = \\prod_{s=1}^t \\alpha_s\\)\n\\(\\beta_t\\): Variance of the noise added at step \\(t\\), typically \\(\\beta_t = 1 - \\alpha_t\\)\n\\(x_0\\): Original clean data sample (e.g., image)\n\\(x_t\\): Noisy version of \\(x_0\\) at timestep \\(t\\)\n\\(\\epsilon\\): Standard Gaussian noise sampled from \\(\\mathcal{N}(0, I)\\)\n\\(\\tilde{\\mu}_t\\): Mean of the reverse process distribution at time \\(t\\)\n\\(\\tilde{\\beta}_t\\): Variance of the reverse process distribution at time \\(t\\)\n\n\n\n\n3.1 Deriving \\(q(x_{t-1} \\mid x_t, x_0)\\) Using Bayes‚Äô Rule\nWe can‚Äôt directly evaluate \\(q(x_{t-1} \\mid x_t)\\), but we can derive the posterior \\(q(x_{t-1} \\mid x_t, x_0)\\) using Bayes‚Äô rule:\n\\[\nq(x_{t-1} \\mid x_t, x_0) = \\frac{q(x_t \\mid x_{t-1}, x_0) \\cdot q(x_{t-1} \\mid x_0)}{q(x_t \\mid x_0)}\n\\]\nFrom the forward process, we know:\n\n\\(q(x_t \\mid x_{t-1}) = \\mathcal{N}(x_t; \\sqrt{\\alpha_t} x_{t-1},\\, \\beta_t I)\\)\n\n\\(q(x_{t-1} \\mid x_0) = \\mathcal{N}(x_{t-1}; \\sqrt{\\bar{\\alpha}_{t-1}} x_0,\\, (1 - \\bar{\\alpha}_{t-1}) I)\\)\n\n\\(q(x_t \\mid x_0) = \\mathcal{N}(x_t; \\sqrt{\\bar{\\alpha}_t} x_0,\\, (1 - \\bar{\\alpha}_t) I)\\)\n\nTo derive a usable form of the posterior, we substitute the Gaussian densities into Bayes‚Äô rule. The multivariate normal density is:\n\\[\n\\mathcal{N}(x \\mid \\mu, \\Sigma) \\propto \\exp\\left( -\\frac{1}{2}(x - \\mu)^T \\Sigma^{-1} (x - \\mu) \\right)\n\\]\nSince all covariances here are multiples of the identity matrix, \\(\\Sigma = \\sigma^2 I\\), the formula simplifies to:\n\\[\n\\mathcal{N}(x \\mid \\mu, \\sigma^2 I) \\propto \\exp\\left( -\\frac{1}{2\\sigma^2} \\|x - \\mu\\|^2 \\right)\n\\]\n\n\n\n\n\n\nUnderstanding the squared norm\n\n\n\nThe expression \\(\\|x - \\mu\\|^2\\) is the squared distance between two vectors. In 1D, it‚Äôs just \\((x - \\mu)^2\\), but in higher dimensions, it becomes:\n\\[\n\\|x - \\mu\\|^2 = \\sum_{i=1}^d (x_i - \\mu_i)^2\n\\]\nThis term appears in the exponent of the Gaussian and represents how far the sample is from the center (mean), scaled by the variance.\n\n\nApplying this to the forward process terms:\n\n\\(q(x_t \\mid x_{t-1}) \\propto \\exp\\left( -\\frac{1}{2\\beta_t} \\| x_t - \\sqrt{\\alpha_t} x_{t-1} \\|^2 \\right)\\)\n\n\\(q(x_{t-1} \\mid x_0) \\propto \\exp\\left( -\\frac{1}{2(1 - \\bar{\\alpha}_{t-1})} \\| x_{t-1} - \\sqrt{\\bar{\\alpha}_{t-1}} x_0 \\|^2 \\right)\\)\n\nWe can ignore \\(q(x_t \\mid x_0)\\) in the denominator, since it is independent of \\(x_{t-1}\\) and will be absorbed into a proportionality constant.\nPutting these together:\n\\[\nq(x_{t-1} \\mid x_t, x_0) \\propto \\exp\\left(\n-\\frac{1}{2} \\left[\n\\frac{ \\|x_t - \\sqrt{\\alpha_t} x_{t-1} \\|^2 }{\\beta_t} +\n\\frac{ \\| x_{t-1} - \\sqrt{\\bar{\\alpha}_{t-1}} x_0 \\|^2 }{1 - \\bar{\\alpha}_{t-1}}\n\\right]\n\\right)\n\\]\n\n\n\n\n\n\nWhy does the product of Gaussians give another Gaussian?\n\n\n\nWhen we multiply two Gaussian distributions over the same variable, the result is also a Gaussian.\nHere, we are multiplying two Gaussians in \\(x_{t-1}\\):\n- One centered at \\(\\sqrt{\\alpha_t} x_t\\)\n- One centered at \\(\\sqrt{\\bar{\\alpha}_{t-1}} x_0\\)\nThe product is another Gaussian in \\(x_{t-1}\\), with a new mean that is a weighted average of both.\nWe‚Äôll derive this explicitly by completing the square in the exponent.\n\n\n\nAlthough we won‚Äôt use this posterior directly during sampling, this closed-form expression is essential for defining the ELBO used in training. It gives us a precise target that the reverse model attempts to approximate.\n\nWe now complete the square to put the expression into standard Gaussian form.\n\n\n\n3.2 Complete the square\nWe complete the square by rewriting the quadratic expression in a way that matches the standard form of a Gaussian. This lets us rewrite the posterior \\(q(x_{t-1} \\mid x_t, x_0)\\) in standard Gaussian form by identifying its mean and variance.\n\\[\na x^2 - 2 b x = a \\left( x - \\frac{b}{a} \\right)^2 - \\frac{b^2}{a}\n\\]\nFrom earlier, we arrived at this expression for the exponent of the posterior:\n\\[\n-\\frac{1}{2} \\left[\n\\frac{(x_t - \\sqrt{\\alpha_t} \\, x_{t-1})^2}{\\beta_t} +\n\\frac{(x_{t-1} - \\sqrt{\\bar{\\alpha}_{t-1}} \\, x_0)^2}{1 - \\bar{\\alpha}_{t-1}}\n\\right]\n\\]\nWe expand both terms:\nFirst term:\n\\[\n\\frac{(x_t - \\sqrt{\\alpha_t} \\, x_{t-1})^2}{\\beta_t}\n= \\frac{x_t^2 - 2 \\sqrt{\\alpha_t} \\, x_t x_{t-1} + \\alpha_t x_{t-1}^2}{\\beta_t}\n\\]\nSecond term:\n\\[\n\\frac{(x_{t-1} - \\sqrt{\\bar{\\alpha}_{t-1}} \\, x_0)^2}{1 - \\bar{\\alpha}_{t-1}}\n= \\frac{x_{t-1}^2 - 2 \\sqrt{\\bar{\\alpha}_{t-1}} \\, x_{t-1} x_0 + \\bar{\\alpha}_{t-1} x_0^2}{1 - \\bar{\\alpha}_{t-1}}\n\\]\nGroup like terms\nNow we collect all the terms involving \\(x_{t-1}\\):\nCoefficient of \\(x_{t-1}^2\\):\n\\[\na = \\frac{\\alpha_t}{\\beta_t} + \\frac{1}{1 - \\bar{\\alpha}_{t-1}}\n\\]\nCoefficient of \\(x_{t-1}\\) (the full linear term):\n\\[\n-2 \\left(\n\\frac{ \\sqrt{\\alpha_t} \\, x_t }{ \\beta_t } + \\frac{ \\sqrt{\\bar{\\alpha}_{t-1}} \\, x_0 }{ 1 - \\bar{\\alpha}_{t-1} }\n\\right)\n\\]\nSo we define:\n\\[\nb = \\frac{ \\sqrt{\\alpha_t} \\, x_t }{ \\beta_t } + \\frac{ \\sqrt{\\bar{\\alpha}_{t-1}} \\, x_0 }{ 1 - \\bar{\\alpha}_{t-1} }\n\\]\nRemaining terms (like \\(x_t^2\\) and \\(x_0^2\\)) are independent of \\(x_{t-1}\\) and can be absorbed into a constant.\nWe are modeling the conditional distribution \\(q(x_{t-1} \\mid x_t, x_0)\\), which means both \\(x_t\\) and \\(x_0\\) are known and fixed. So any expression involving only \\(x_t\\) or \\(x_0\\) behaves like a constant and does not influence the shape of the Gaussian over \\(x_{t-1}\\).\nThe exponent now has the form:\n\\[\n-\\frac{1}{2} \\left( a x_{t-1}^2 - 2 b x_{t-1} \\right) + \\text{(constants)}\n\\]\nApply the identity\nUsing the identity: \\[\na x^2 - 2 b x = a \\left( x - \\frac{b}{a} \\right)^2 - \\frac{b^2}{a}\n\\]\nwe rewrite the exponent: \\[\n-\\frac{1}{2} \\left( a x_{t-1}^2 - 2 b x_{t-1} \\right)\n= -\\frac{1}{2} \\left[ a \\left( x_{t-1} - \\frac{b}{a} \\right)^2 - \\frac{b^2}{a} \\right]\n\\]\nWe drop the constant term \\(\\frac{b^2}{a}\\) under proportionality. This transforms the exponent into the Gaussian form: \\[\nq(x_{t-1} \\mid x_t, x_0) \\propto \\exp\\left(\n- \\frac{1}{2 \\tilde{\\beta}_t} \\| x_{t-1} - \\tilde{\\mu}_t \\|^2\n\\right)\n\\]\n\n\n\n\n\n\nNote: This matches the standard Gaussian\n\n\n\nThe standard Gaussian is written as: \\[\n\\mathcal{N}(x \\mid \\mu, \\sigma^2 I) \\propto \\exp\\left(\n- \\frac{1}{2\\sigma^2} \\| x - \\mu \\|^2\n\\right)\n\\]\nSo in our case:\n\n\\(\\tilde{\\mu}_t = \\frac{b}{a}\\) is the mean\n\\(\\tilde{\\beta}_t = \\frac{1}{a}\\) is the variance\n\nWe keep the notation \\(\\tilde{\\beta}_t\\) instead of \\(\\sigma^2\\) because it connects directly to the noise schedule (\\(\\beta_t\\), \\(\\bar{\\alpha}_t\\)) used in the diffusion model. This helps tie everything back to how the forward and reverse processes relate.\n\n\nFinal expressions\nNow we can directly read off the expressions for the mean and variance from the completed square.\nWe had: \\[\na = \\frac{\\alpha_t}{\\beta_t} + \\frac{1}{1 - \\bar{\\alpha}_{t-1}}, \\quad\nb = \\frac{\\sqrt{\\alpha_t} \\, x_t}{\\beta_t} + \\frac{\\sqrt{\\bar{\\alpha}_{t-1}} \\, x_0}{1 - \\bar{\\alpha}_{t-1}}\n\\]\nFrom the identity: \\[\nq(x_{t-1} \\mid x_t, x_0) \\propto \\exp\\left(\n- \\frac{1}{2 \\tilde{\\beta}_t} \\| x_{t-1} - \\tilde{\\mu}_t \\|^2\n\\right)\n\\]\nwe identify: - \\(\\tilde{\\mu}_t = \\frac{b}{a}\\), - \\(\\tilde{\\beta}_t = \\frac{1}{a}\\)\nLet‚Äôs compute these explicitly:\nMean: \\[\n\\tilde{\\mu}_t = \\frac{b}{a} =\n\\frac{\n\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_{t-1}) x_t +\n\\sqrt{\\bar{\\alpha}_{t-1}} \\beta_t x_0\n}{\n1 - \\bar{\\alpha}_t\n}\n\\]\nVariance: \\[\n\\tilde{\\beta}_t = \\frac{1}{a}\n= \\frac{1 - \\bar{\\alpha}_{t-1}}{1 - \\bar{\\alpha}_t} \\cdot \\beta_t\n\\]\nSo the final expression for the posterior becomes: \\[\nq(x_{t-1} \\mid x_t, x_0) = \\mathcal{N}(x_{t-1};\\, \\tilde{\\mu}_t,\\, \\tilde{\\beta}_t I)\n\\]\n\n\n3.3 Parameterizing the Reverse Process\nDuring training, we can compute the posterior exactly because \\(x_0\\) is known. But at sampling time, we don‚Äôt have access to \\(x_0\\), so we must express everything in terms of the current noisy sample \\(x_t\\) and the model‚Äôs prediction of noise \\(\\epsilon\\).\nWe start from the forward noising equation:\n\\[\nx_t = \\sqrt{\\bar{\\alpha}_t} \\, x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon\n\\]\nThis expresses how noise is added to the clean image \\(x_0\\) to produce the noisy observation \\(x_t\\).\nWe rearrange this to solve for \\(x_0\\) in terms of \\(x_t\\) and \\(\\epsilon\\):\n\\[\nx_0 = \\frac{x_t - \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon}{\\sqrt{\\bar{\\alpha}_t}}\n\\]\nNow we substitute this into the posterior mean expression \\(\\tilde{\\mu}_t\\), which originally depended on \\(x_0\\):\n\\[\n\\tilde{\\mu}_t =\n\\frac{\n\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_{t-1}) x_t +\n\\sqrt{\\bar{\\alpha}_{t-1}} \\beta_t x_0\n}{\n1 - \\bar{\\alpha}_t\n}\n\\]\nSubstituting \\(x_0\\) into this gives:\n\\[\n\\tilde{\\mu}_t =\n\\frac{1}{\\sqrt{\\alpha_t}} \\left( x_t - \\frac{\\beta_t}{\\sqrt{1 - \\bar{\\alpha}_t}} \\, \\epsilon \\right)\n\\]\nThis allows us to compute the mean of the reverse process using only \\(x_t\\), \\(\\epsilon\\), and known scalars from the noise schedule.\n\n\\(\\epsilon\\) is the noise that was added to \\(x_0\\) to get \\(x_t\\)\nAt test time, we use the model‚Äôs prediction \\(\\epsilon_\\theta(x_t, t)\\) in its place\n\n\n\n3.4 Recap: Reverse Diffusion Steps\n\n\n\n\n\n\n\n\nStep\nFormula\nExplanation\n\n\n\n\n1\n\\(q(x_{t-1} \\mid x_t, x_0)\\)\nTrue posterior used during training (when \\(x_0\\) is known)\n\n\n2\n\\(\\tilde{\\mu}_t = \\dfrac{1}{\\sqrt{\\alpha_t}} \\left( x_t - \\dfrac{\\beta_t}{\\sqrt{1 - \\bar{\\alpha}_t}} \\, \\epsilon \\right)\\)\nPosterior mean rewritten using \\(x_t\\) and noise\n\n\n3\n\\(\\epsilon \\approx \\epsilon_\\theta(x_t, t)\\)\nAt test time, model predicts the noise\n\n\n4\n\\(p_\\theta(x_{t-1} \\mid x_t) = \\mathcal{N}(\\tilde{\\mu}_t, \\tilde{\\beta}_t I)\\)\nReverse step sampled from model‚Äôs predicted mean and fixed variance\n\n\n\n\n\n3.5 Key Takeaways\n\nThe reverse diffusion process defines a learned Markov chain that gradually removes noise from the input.\nAlthough we can‚Äôt compute the true reverse distribution \\(q(x_{t-1} \\mid x_t)\\), we derive a tractable Gaussian approximation using Bayes‚Äô rule.\nThe reverse mean depends on both \\(x_t\\) and the original data \\(x_0\\), but at test time we use the model‚Äôs prediction of noise \\(\\epsilon_\\theta(x_t, t)\\) to estimate \\(x_0\\).\nThe reverse steps preserve a Gaussian structure, enabling efficient sampling using the predicted mean \\(\\mu_\\theta(x_t, t)\\) and fixed variance \\(\\Sigma_\\theta(x_t, t)\\)."
  },
  {
    "objectID": "diffusion.html#training-understanding-the-elbo",
    "href": "diffusion.html#training-understanding-the-elbo",
    "title": "Diffusion Models",
    "section": "4 Training: Understanding the ELBO",
    "text": "4 Training: Understanding the ELBO\nWhat is the Goal? The ultimate goal in diffusion models is to train the neural network so that it can reverse the noising process. In other words, we want the network to learn how to turn random noise back into realistic data (like images). But how do we actually train the network? We need a loss function‚Äîa way to measure how good or bad the network‚Äôs predictions are, so we can improve it.\n\n4.1 What is the ELBO?\nThe ELBO is a lower bound on the log-likelihood of the data. Maximizing the ELBO is equivalent to maximizing the likelihood that the model can generate the training data. For diffusion models, the ELBO ensures that the reverse process (denoising) aligns with the forward process (noising).\n\n\n4.2 Deriving the ELBO for Diffusion Models\nGoal:\nWe want to maximize the log-likelihood of the data:\n\\[\n\\log p_\\theta(x_0)\n\\]\nwhere \\(x_0\\) is a clean data sample (e.g., an image).\nProblem:\nComputing \\(\\log p_\\theta(x_0)\\) directly is intractable because it involves integrating over all possible noisy intermediate states \\(x_{1:T}\\).\nSolution:\nUse Jensen‚Äôs Inequality to derive a lower bound (the ELBO) that we can optimize instead.\n\n\n4.3 Full Derivation (Step-by-Step)\nStep 1: Start with the log-likelihood\n\\[\n\\log p_\\theta(x_0) = \\log \\int p_\\theta(x_{0:T}) \\, dx_{1:T}\n\\]\nStep 2: Introduce the forward process \\(q(x_{1:T} \\mid x_0)\\)\nMultiply and divide by the fixed forward process:\n\\[\n\\log p_\\theta(x_0) = \\log \\int \\frac{p_\\theta(x_{0:T})}{q(x_{1:T} \\mid x_0)} q(x_{1:T} \\mid x_0) \\, dx_{1:T}\n\\]\nStep 3: Rewrite as an expectation\n\\[\n\\log p_\\theta(x_0) = \\log \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[ \\frac{p_\\theta(x_{0:T})}{q(x_{1:T} \\mid x_0)} \\right]\n\\]\nStep 4: Apply Jensen‚Äôs Inequality\n\\[\n\\log p_\\theta(x_0) \\geq \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[ \\log \\frac{p_\\theta(x_{0:T})}{q(x_{1:T} \\mid x_0)} \\right]\n\\]\nStep 5: Expand \\(p_\\theta(x_{0:T})\\) and \\(q(x_{1:T} \\mid x_0)\\)\nThe reverse (generative) process is:\n\\[\np_\\theta(x_{0:T}) = p(x_T) \\cdot \\prod_{t=1}^T p_\\theta(x_{t-1} \\mid x_t)\n\\]\nThe forward (noising) process is:\n\\[\nq(x_{1:T} \\mid x_0) = \\prod_{t=1}^T q(x_t \\mid x_{t-1})\n\\]\nSubstitute both into the ELBO:\n\\[\n\\text{ELBO} = \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[\n\\log \\left(\n\\frac{p(x_T) \\cdot \\prod_{t=1}^T p_\\theta(x_{t-1} \\mid x_t)}\n     {\\prod_{t=1}^T q(x_t \\mid x_{t-1})}\n\\right)\n\\right]\n\\]\nSplit the logarithm:\n\\[\n\\text{ELBO} = \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[\n\\log p(x_T)\n+ \\sum_{t=1}^T \\log p_\\theta(x_{t-1} \\mid x_t)\n- \\sum_{t=1}^T \\log q(x_t \\mid x_{t-1})\n\\right]\n\\]\nGroup the terms:\n\\[\n\\text{ELBO} = \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[\n\\log p(x_T)\n+ \\sum_{t=1}^T \\log \\frac{p_\\theta(x_{t-1} \\mid x_t)}{q(x_t \\mid x_{t-1})}\n\\right]\n\\]\nStep 6: Decompose the ELBO\nWe now break down the Evidence Lower Bound (ELBO) into three interpretable components:\n\nThe prior loss ‚Äî how well the final noisy sample matches the prior\n\nThe denoising KL terms ‚Äî how well the model learns to denoise at each timestep\n\nThe reconstruction loss ‚Äî how well the model recovers the original input\n\nELBO Expression from Previous Step\n\\[\n= \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[\n\\log p(x_T) + \\sum_{t=1}^T \\log \\frac{p_\\theta(x_{t-1} \\mid x_t)}{q(x_t \\mid x_{t-1})}\n\\right]\n\\]\nIsolating the Reconstruction Term\nThe case for \\(t = 1\\) is special: it‚Äôs the step where the model tries to reconstruct \\(x_0\\) from \\(x_1\\). So we isolate it from the rest of the trajectory-based KL terms.\n\\[\n= \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[\n\\log p(x_T)\n+ \\sum_{t=2}^T \\log \\frac{p_\\theta(x_{t-1} \\mid x_t)}{q(x_t \\mid x_{t-1})}\n+ \\log \\frac{p_\\theta(x_0 \\mid x_1)}{q(x_1 \\mid x_0)}\n\\right]\n\\]\nRewriting Using the Known Forward Process\nThe forward process gives us a complete description of how noise is added to data. Because of this, we can calculate the exact probability of earlier steps given later ones. In particular, since both \\(x_t\\) and \\(x_0\\) are known during training, we can compute the true backward distribution \\(q(x_{t-1} \\mid x_t, x_0)\\). This lets us directly compare it to the model‚Äôs learned reverse process \\(p_\\theta(x_{t-1} \\mid x_t)\\).\nThis gives:\n\\[\n= \\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[\n\\log p(x_T)\n+ \\sum_{t=2}^T \\log \\frac{p_\\theta(x_{t-1} \\mid x_t)}{q(x_{t-1} \\mid x_t, x_0)}\n+ \\log p_\\theta(x_0 \\mid x_1)\n- \\log q(x_1 \\mid x_0)\n\\right]\n\\]\nThe last term, \\(\\log q(x_1 \\mid x_0)\\), comes from the known forward process and does not depend on the model parameters. Since it stays constant during training, we drop it from the objective and retain the remaining three terms.\nThe first two log-ratios can now be rewritten as KL divergences, and the third term becomes a standard reconstruction loss.\nRewriting the First Term as a KL Divergence\nWe begin with the first term from the ELBO expression:\n\\[\n\\mathbb{E}_{q(x_{1:T} \\mid x_0)} \\left[ \\log p(x_T) \\right]\n\\]\nSince this expectation only involves \\(x_T\\), we can simplify it as:\n\\[\n\\mathbb{E}_{q(x_T \\mid x_0)} \\left[ \\log p(x_T) \\right]\n\\]\nNow recall the definition of KL divergence between two distributions \\(q(x)\\) and \\(p(x)\\):\n\\[\nD_{\\text{KL}}(q(x) \\,\\|\\, p(x)) = \\mathbb{E}_{q(x)} \\left[ \\log \\frac{q(x)}{p(x)} \\right]\n= \\mathbb{E}_{q(x)} [\\log q(x)] - \\mathbb{E}_{q(x)} [\\log p(x)]\n\\]\nRearranging this gives:\n\\[\n\\mathbb{E}_{q(x)} [\\log p(x)] = -D_{\\text{KL}}(q(x) \\,\\|\\, p(x)) + \\mathbb{E}_{q(x)} [\\log q(x)]\n= -D_{\\text{KL}}(q(x) \\,\\|\\, p(x)) + \\mathbb{H}[q(x)]\n\\]\nApplying this identity to \\(q(x_T \\mid x_0)\\) ‚Äî which is analytically tractable due to the known forward process ‚Äî and the prior \\(p(x_T)\\):\n\\[\n\\mathbb{E}_{q(x_T \\mid x_0)} [\\log p(x_T)] = -D_{\\text{KL}}(q(x_T \\mid x_0) \\,\\|\\, p(x_T)) + \\mathbb{H}[q(x_T \\mid x_0)]\n\\]\nSince \\(q(x_T \\mid x_0)\\) is part of the fixed forward process, its entropy \\(\\mathbb{H}[q(x_T \\mid x_0)]\\) is independent of model parameters and can be ignored during training. So we drop it:\n\\[\n\\mathbb{E}_{q(x_T \\mid x_0)} [\\log p(x_T)]\n\\approx -D_{\\text{KL}}(q(x_T \\mid x_0) \\parallel p(x_T))\n\\quad \\text{(ignoring constant entropy term)}\n\\]\nThis shows that the first term in the ELBO corresponds to \\(D_{\\text{KL}}(q(x_T \\mid x_0) \\,\\|\\, p(x_T))\\), comparing the forward process at time \\(T\\) to the model‚Äôs prior.\nRewriting the Second Terms as KL Divergences\nNext, we consider the sum of log-ratio terms from the ELBO expression:\n\\[\n\\sum_{t=2}^T \\mathbb{E}_q \\left[ \\log \\frac{p_\\theta(x_{t-1} \\mid x_t)}{q(x_{t-1} \\mid x_t, x_0)} \\right]\n\\]\nThis expression compares two distributions:\n\n\\(p_\\theta(x_{t-1} \\mid x_t)\\): the model‚Äôs learned reverse (denoising) process\n\n\\(q(x_{t-1} \\mid x_t, x_0)\\): the true posterior over \\(x_{t-1}\\) given \\(x_t\\) and the original data \\(x_0\\)\n(this is computable in closed-form since the forward process is known)\n\nNow recall the definition of KL divergence:\n\\[\nD_{\\text{KL}}(q(x) \\,\\|\\, p(x)) = \\mathbb{E}_{q(x)} \\left[ \\log \\frac{q(x)}{p(x)} \\right]\n\\]\nIf we flip the log-ratio, we get:\n\\[\n\\mathbb{E}_{q(x)} \\left[ \\log \\frac{p(x)}{q(x)} \\right] = - D_{\\text{KL}}(q(x) \\,\\|\\, p(x))\n\\]\nSo each log term becomes the negative KL divergence:\n\\[\n\\mathbb{E}_q \\left[ \\log \\frac{p_\\theta(x_{t-1} \\mid x_t)}{q(x_{t-1} \\mid x_t, x_0)} \\right]\n= - D_{\\text{KL}}(q(x_{t-1} \\mid x_t, x_0) \\,\\|\\, p_\\theta(x_{t-1} \\mid x_t))\n\\]\nApplying this for every timestep from \\(t = 2\\) to \\(T\\), we get:\n\\[\n\\sum_{t=2}^T \\mathbb{E}_q \\left[ \\log \\frac{p_\\theta(x_{t-1} \\mid x_t)}{q(x_{t-1} \\mid x_t, x_0)} \\right]\n= - \\sum_{t=2}^T D_{\\text{KL}}(q(x_{t-1} \\mid x_t, x_0) \\,\\|\\, p_\\theta(x_{t-1} \\mid x_t))\n\\]\nThis shows that the middle terms in the ELBO can be rewritten as a sum of KL divergences between the true posterior and the model‚Äôs learned reverse process at each timestep.\nRewriting the Third Term as a Reconstruction Loss\nThe last part of the ELBO expression is:\n\\[\n\\mathbb{E}_q \\left[ \\log p_\\theta(x_0 \\mid x_1) \\right]\n\\]\nThis term does not involve any KL divergence ‚Äî it directly corresponds to the model‚Äôs attempt to reconstruct the original input \\(x_0\\) from \\(x_1\\).\n\n\\(x_1\\) is a slightly noisy version of \\(x_0\\) (after one step of the forward process).\n\\(p_\\theta(x_0 \\mid x_1)\\) is the model‚Äôs decoder ‚Äî it tries to map the noisy input \\(x_1\\) back to the clean data \\(x_0\\).\n\nDuring training, this term is treated as a standard log-likelihood loss. Since we want to maximize the ELBO, we want to maximize this log-probability ‚Äî which is equivalent to minimizing the negative log-likelihood:\n\\[\n- \\log p_\\theta(x_0 \\mid x_1)\n\\]\nThis is why the reconstruction term appears with a positive sign in the loss (as a value we minimize), but a negative sign inside the ELBO.\nThis is referred to as the reconstruction loss in diffusion models.\nIf \\(p_\\theta(x_0 \\mid x_1)\\) is modeled as a Gaussian, this term becomes a mean squared error between the predicted and true \\(x_0\\) values.\nELBO vs.¬†Loss\nWe write the ELBO as:\n\\[\n\\text{ELBO} =\n\\underbrace{- D_{\\text{KL}}(q(x_T \\mid x_0) \\parallel p(x_T))}_{\\mathcal{L}_T}\n\\quad\n\\underbrace{- \\sum_{t=2}^T D_{\\text{KL}}(q(x_{t-1} \\mid x_t, x_0) \\parallel p_\\theta(x_{t-1} \\mid x_t))}_{\\mathcal{L}_{1:T-1}}\n\\quad\n\\underbrace{+ \\mathbb{E}_q \\left[ \\log p_\\theta(x_0 \\mid x_1) \\right]}_{\\mathcal{L}_0}\n\\]\nSince we minimize loss instead of maximizing ELBO, we flip the sign.\nWe write the loss as:\n\\[\n\\text{Loss} =\n\\underbrace{+ D_{\\text{KL}}(q(x_T \\mid x_0) \\parallel p(x_T))}_{\\mathcal{L}_T}\n\\quad\n\\underbrace{+ \\sum_{t=2}^T D_{\\text{KL}}(q(x_{t-1} \\mid x_t, x_0) \\parallel p_\\theta(x_{t-1} \\mid x_t))}_{\\mathcal{L}_{1:T-1}}\n\\quad\n\\underbrace{- \\mathbb{E}_q \\left[ \\log p_\\theta(x_0 \\mid x_1) \\right]}_{\\mathcal{L}_0}\n\\]\n\n\n4.4 Interpreting Each Term in the ELBO\nReconstruction Loss (\\(\\mathcal{L}_0\\))\n- Encourages the model to reconstruct \\(x_0\\) from the first noisy sample \\(x_1\\)\n- Comes from the log-probability term \\(\\log p_\\theta(x_0 \\mid x_1)\\)\n- Treated as a negative log-likelihood (e.g., MSE if modeled as Gaussian)\nPrior Matching Loss (\\(\\mathcal{L}_T\\))\n- Penalizes mismatch between the final noisy sample \\(x_T\\) and the prior \\(p(x_T)\\)\n- Comes from the KL divergence \\(D_{\\text{KL}}(q(x_T \\mid x_0) \\parallel p(x_T))\\)\n- Ensures the generative process starts from pure noise\nDenoising KL Terms (\\(\\mathcal{L}_{1:T-1}\\))\n- Encourage the model to learn the correct reverse step at each \\(t = 2\\) to \\(T\\)\n- Each term compares \\(q(x_{t-1} \\mid x_t, x_0)\\) to the learned \\(p_\\theta(x_{t-1} \\mid x_t)\\)\n- Drives step-by-step denoising behavior\n\n\n\n\n\n\nBridging ELBO and the DDPM Training Loss\n\n\n\nThe ELBO gives us a principled objective that encourages the learned reverse process to match the true posterior. In practice, however, the KL terms can be simplified when we assume Gaussian forward and reverse processes.\nThis lets us rewrite the training objective in terms of the model‚Äôs ability to predict the noise \\(\\epsilon\\) that was added during the forward process.\n\n\nThis lets us rewrite the training objective in terms of the model‚Äôs ability to predict the noise \\(\\epsilon\\) that was added during the forward process.\n\n\n4.5 The core loss used in DDPM training\nWhen all forward and reverse steps in the diffusion process are modeled as Gaussians, the KL terms in the ELBO can be simplified significantly.\nFor example, the KL divergence between the true posterior \\(q(x_{t-1} \\mid x_t, x_0)\\) and the model‚Äôs reverse process \\(p_\\theta(x_{t-1} \\mid x_t)\\) becomes:\n\\[\nD_{\\text{KL}}\\left( q(x_{t-1} \\mid x_t, x_0) \\;\\|\\; p_\\theta(x_{t-1} \\mid x_t) \\right)\n\\]\nSince both distributions are Gaussian, this KL has a closed-form expression. If we fix the variances and only match the means, minimizing the KL reduces to a squared error loss between the true noise \\(\\epsilon\\) and the model‚Äôs prediction \\(\\epsilon_\\theta\\).\nTo approximate the ELBO in practice, DDPM uses a simplified MSE loss between the predicted and true noise:\n\\[\n\\mathcal{L}_{\\text{simple}} = \\mathbb{E}_{x_0, t, \\epsilon} \\left[\n\\left\\| \\epsilon - \\epsilon_\\theta(x_t, t) \\right\\|^2\n\\right]\n\\]\nIn the forward process, the noisy sample \\(x_t\\) is generated from \\(x_0\\) by adding scaled Gaussian noise \\(\\epsilon\\):\n\\[\nx_t = \\sqrt{\\bar{\\alpha}_t} \\, x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon\n\\]\nThe network input originally is \\(x_t\\), but now we explicitly substitute its definition:\n\\[\n\\epsilon_\\theta(x_t, t)\n\\quad \\Rightarrow \\quad\n\\epsilon_\\theta\\left( \\sqrt{\\bar{\\alpha}_t} \\, x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon, \\, t \\right)\n\\]\nWe now substitute this new expression into the full loss:\n\\[\n\\mathcal{L}_{\\text{simple}} = \\mathbb{E}_{x_0, t, \\epsilon} \\left[\n\\left\\| \\epsilon -\n\\epsilon_\\theta\\left( \\sqrt{\\bar{\\alpha}_t} \\, x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon, \\, t \\right)\n\\right\\|^2\n\\right]\n\\]\nThis is the fully expanded form of the DDPM loss used during training.\n\nThe model receives a noisy input \\(x_t\\) that is synthesized from \\(x_0\\) and \\(\\epsilon\\)\nIt tries to predict the exact noise \\(\\epsilon\\) that was added\nThe loss compares the true noise to the predicted noise, and minimizes their difference using squared error\n\n\n\n\n\n\n\nHow the ELBO Helps Us Understand the MSE Loss\n\n\n\nEven though we end up training with a simplified MSE loss in DDPM, deriving the full ELBO helps us understand what the model is truly learning ‚Äî and why the simplification works.\n\nThe ELBO gives us a principled, variational objective\nIt tells us that training involves matching noise distributions and reconstructing data step-by-step\nThe simplified DDPM loss is an approximation of the denoising KL terms (\\(\\mathcal{L}_{1:T-1}\\))\nOther terms (like \\(\\mathcal{L}_T\\) and \\(\\mathcal{L}_0\\)) are often treated as constants or dropped for efficiency\nMany advanced diffusion models return to the ELBO to add back or rethink these terms\n\nSo the ELBO is like the blueprint ‚Äî and the DDPM loss is an optimized shortcut that works because we understand the full path.\n\n\n\n\n4.6 The Noise Prediction Network\nNow that we‚Äôve arrived at the simplified training loss used in DDPM, let‚Äôs understand what the model is actually learning.\n\n4.6.1 What the Network Learns\n\nDuring training, we know the true noise \\(\\epsilon\\) used to generate the noisy sample \\(x_t\\) from \\(x_0\\)\n\nThe network \\(\\epsilon_\\theta(x_t, t)\\) is trained to predict this noise\n\nOnce trained, the model can use this prediction to ‚Äúundo‚Äù the noise and reconstruct \\(x_0\\) at test time\n\n\n\n4.6.2 Why Predicting Noise Works\nRecall the forward process:\n\\[\nx_t = \\sqrt{\\bar{\\alpha}_t} x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon\n\\]\nRearranging this gives an estimate of the original (clean) image:\n\\[\nx_0 = \\frac{1}{\\sqrt{\\bar{\\alpha}_t}} \\left( x_t - \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon \\right)\n\\]\nThis is exactly why the DDPM training objective minimizes\n\\[\n\\left\\| \\epsilon - \\epsilon_\\theta(x_t, t) \\right\\|^2\n\\]\n‚Äî because if we can predict the noise, we can recover the clean image \\(x_0\\).\nThis denoised estimate is also used during sampling to compute the mean of the reverse distribution \\(q(x_{t-1} \\mid x_t, x_0)\\) ‚Äî which is key to reversing the diffusion process one step at a time."
  },
  {
    "objectID": "diffusion.html#training-and-sampling-algorithms-ddpm",
    "href": "diffusion.html#training-and-sampling-algorithms-ddpm",
    "title": "Diffusion Models",
    "section": "6 Training and Sampling Algorithms (DDPM)",
    "text": "6 Training and Sampling Algorithms (DDPM)\n\n6.1 Algorithm: Training (DDPM)\nSteps: - Sample a data point:‚ÄÉ\\(x_0 \\sim q(x_0)\\)\n- Choose a timestep:‚ÄÉ\\(t \\sim \\text{Uniform}(\\{1, \\dots, T\\})\\)\n- Sample noise:‚ÄÉ\\(\\epsilon \\sim \\mathcal{N}(0, I)\\)\n- Take a gradient step to minimize loss\nThe training loss is:\n\\[\n\\mathcal{L}_{\\text{simple}} = \\mathbb{E}_{x_0, t, \\epsilon} \\left[ \\left\\| \\epsilon - \\epsilon_\\theta\\left( \\sqrt{\\bar{\\alpha}_t} x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\, \\epsilon, t \\right) \\right\\|^2 \\right]\n\\]\nExplanation\n- Sample a real data point \\(x_0\\)\n- Corrupt it to get \\(x_t\\) using the forward noising process\n- Train \\(\\epsilon_\\theta\\) to predict the added noise \\(\\epsilon\\)\n- Optimize using mean squared error between predicted and true noise\n\n\n\n6.2 Algorithm: Sampling (DDPM)\nSteps: - Start with noise:‚ÄÉ\\(x_T \\sim \\mathcal{N}(0, I)\\)\n- For \\(t = T, \\dots, 1\\):\n‚ÄÉ‚ÄÉ- \\(z \\sim \\mathcal{N}(0, I)\\) if \\(t &gt; 1\\), else \\(z = 0\\)\n‚ÄÉ‚ÄÉ- Use predicted noise to update \\(x_{t-1}\\)\n- Return \\(x_0\\)\nThe update equation is:\n\\[\nx_{t-1} = \\frac{1}{\\sqrt{\\alpha_t}} \\left( x_t - \\frac{1 - \\alpha_t}{\\sqrt{1 - \\bar{\\alpha}_t}} \\, \\epsilon_\\theta(x_t, t) \\right) + \\sigma_t z\n\\]\nExplanation\n- Start from pure Gaussian noise \\(x_T\\)\n- At each timestep \\(t\\), use \\(\\epsilon_\\theta\\) to estimate and remove noise\n- Add back a small amount of Gaussian noise \\(z\\)\n- Continue until you obtain a clean sample \\(x_0\\)"
  },
  {
    "objectID": "diffusion.html#tricks-for-improving-generation",
    "href": "diffusion.html#tricks-for-improving-generation",
    "title": "Diffusion Models",
    "section": "7 Tricks for Improving Generation",
    "text": "7 Tricks for Improving Generation\nWhile the original DDPM formulation already achieves impressive results, several refinements have been proposed to improve sample quality and likelihood estimates. Below are three effective categories of improvements.\n\n7.1 Better Noise Schedules\nIn DDPM, the noise schedule defines how much noise is added at each timestep during the forward process. A common default is a linear schedule, but this can overly distort early inputs:\n\nA linear noise schedule adds noise too aggressively in early steps, quickly erasing structure from \\(x_0\\).\nTo address this, researchers proposed a cosine schedule, where noise increases more gradually near the ends.\n\n\nKey Insight: A cosine schedule preserves structure for longer, giving the reverse process a better chance at learning to denoise effectively ‚Äî even though the choice of cosine was somewhat arbitrary, it empirically works better.\n\n\n\n7.2 Learning the Variance (Covariance Matrix)\nIn the basic DDPM, the reverse process uses a fixed variance (i.e., isotropic Gaussian). However, variance also influences generation:\n\nDDPM authors initially used fixed values:\n\\(\\Sigma_\\theta(x_t, t) = \\sigma_t^2 I\\)\nwhere \\(\\sigma_t^2\\) is either \\(\\beta_t\\) or a smoothed estimate \\(\\tilde{\\beta}_t\\).\nNichol and Dhariwal proposed a learned variance model: \\[\n\\Sigma_\\theta(x_t, t) = \\exp \\left( v \\log \\beta_t + (1 - v) \\log \\tilde{\\beta}_t \\right)\n\\]\n\n\nWhy it helps: While the mean dominates sample quality, a better variance estimate improves likelihood estimation without hurting visual fidelity.\n\n\n\n7.3 Architectural Enhancements\nIn addition to schedule and variance tweaks, the architecture of the denoising network matters:\n\nDepth vs.¬†Width: Wider U-Nets improve sample quality more efficiently than deeper ones.\nMulti-Resolution Attention: Adding attention layers at multiple resolutions enhances the model‚Äôs ability to capture global structure.\nBigGAN Residual Blocks: Using residual blocks from BigGAN for upsampling/downsampling improves learning and gradient flow.\nAdaptive Group Normalization: A normalization technique that conditions on timestep (and class label if available) to help the model adapt better at each denoising step.\n\nThese tricks are often combined in modern diffusion models and form the backbone of high-quality sample generation pipelines like improved DDPMs and diffusion-based image generators (e.g., ADM, Imagen, and Stable Diffusion).\n\n\n7.4 Classifier-Free Guidance\nUsed by: Stable Diffusion, Imagen, DALLE 2, and more.\n\nAllows the model to control generation (e.g., with text prompts) without requiring a separate classifier.\nDuring training, the model sees both conditional and unconditional inputs. During sampling, we guide generation by interpolating the two outputs:\n\n\\[\n\\epsilon_\\theta^{\\text{guided}} = (1 + w) \\cdot \\epsilon_\\theta(x_t, t, y) - w \\cdot \\epsilon_\\theta(x_t, t)\n\\]\nWhere: - \\(w\\) is the guidance scale (typically 1‚Äì5). - \\(y\\) is the conditioning input (e.g., a caption). - \\(\\epsilon_\\theta(x_t, t, y)\\) is the predicted noise with conditioning. - \\(\\epsilon_\\theta(x_t, t)\\) is the predicted noise without conditioning.\nHigher \\(w\\) increases adherence to the prompt ‚Äî but can also reduce diversity or realism.\n\n\n7.5 Improved Samplers (DDIM, DPM-Solver)\nThe original DDPM sampling takes ~1000 steps. These improved samplers accelerate generation dramatically.\n\nDDIM (Denoising Diffusion Implicit Models):\n\nUses a non-Markovian deterministic process.\nCan sample in 10‚Äì50 steps while maintaining high fidelity.\n\nDPM-Solver:\n\nTreats the reverse process as an ODE and solves it directly using numerical methods.\nEven faster than DDIM with excellent sample quality.\n\n\nThese methods let us trade off between speed and quality, enabling practical use in real-time applications."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Deep Generative Models",
    "section": "",
    "text": "Generative machine learning models aim to learn the underlying distribution of real-world data, typically denoted as \\(p_{\\text{data}}(x)\\). Their goal is to approximate this distribution as closely as possible.\n\nThe distribution learned by the model is denoted as \\(p_\\theta(x)\\)\n\nWe generate new data by sampling from this learned distribution\n\nIn practice, generative models are trained to maximize the expected log-likelihood of \\(p_\\theta(x)\\), or equivalently, minimize the divergence between \\(p_\\theta(x)\\) and \\(p_{\\text{data}}(x)\\)\n\n\nüìå Note:\n- Models like Autoregressive models and Normalizing Flows directly maximize log-likelihood.\n- VAEs maximize a variational lower bound (ELBO) on log-likelihood.\n- GANs minimize the Jensen-Shannon divergence through adversarial training.\n- Diffusion models and EBMs use score matching or other divergence-minimizing techniques.\n\nThis site explores how different model families approach this goal ‚Äî from Variational Autoencoders (VAEs) to Diffusion Models ‚Äî grounded in theory and real-world use."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Deep Generative Models",
    "section": "",
    "text": "Generative machine learning models aim to learn the underlying distribution of real-world data, typically denoted as \\(p_{\\text{data}}(x)\\). Their goal is to approximate this distribution as closely as possible.\n\nThe distribution learned by the model is denoted as \\(p_\\theta(x)\\)\n\nWe generate new data by sampling from this learned distribution\n\nIn practice, generative models are trained to maximize the expected log-likelihood of \\(p_\\theta(x)\\), or equivalently, minimize the divergence between \\(p_\\theta(x)\\) and \\(p_{\\text{data}}(x)\\)\n\n\nüìå Note:\n- Models like Autoregressive models and Normalizing Flows directly maximize log-likelihood.\n- VAEs maximize a variational lower bound (ELBO) on log-likelihood.\n- GANs minimize the Jensen-Shannon divergence through adversarial training.\n- Diffusion models and EBMs use score matching or other divergence-minimizing techniques.\n\nThis site explores how different model families approach this goal ‚Äî from Variational Autoencoders (VAEs) to Diffusion Models ‚Äî grounded in theory and real-world use."
  },
  {
    "objectID": "index.html#key-model-families",
    "href": "index.html#key-model-families",
    "title": "Deep Generative Models",
    "section": "2 Key Model Families",
    "text": "2 Key Model Families\n\n\n Variational Autoencoders (VAEs)\n\n\nCore Idea: Encode input to a latent space and reconstruct it while optimizing a lower bound on likelihood (ELBO).\nLikelihood: Approximate (variational lower bound).\nSampling: Fast ‚Äî sample latent vector and decode.\nUse Cases: Representation learning, image generation.\nExample Models: Œ≤-VAE, Conditional VAE\nGo to VAE write-up ‚Üí\n\n\n\n\n Generative Adversarial Networks (GANs)\n\n\nCore Idea: A generator and discriminator compete in a minimax game to produce realistic samples.\nLikelihood: None (implicit model).\nSampling: Fast ‚Äî sample latent vector and pass through generator.\nUse Cases: High-quality image generation, style transfer.\nExample Models: StyleGAN, CycleGAN\n[Go to GAN write-up ‚Üí]\n\n\n\n\n Autoregressive Models\n\n\nCore Idea: Factor the joint distribution as a product of conditional probabilities.\nLikelihood: Exact.\nSampling: Slow ‚Äî token-by-token generation.\nUse Cases: Language modeling, code generation, time series.\nExample Models: GPT, PixelRNN\n[Go to Autoregressive Models ‚Üí]\n\n\n\n\n Normalizing Flows\n\n\nCore Idea: Learn invertible transformations of latent variables using the change-of-variable formula.\nLikelihood: Exact and tractable.\nSampling: Fast ‚Äî sample from base distribution and invert.\nUse Cases: Density estimation, latent space modeling.\nExample Models: RealNVP, Glow\nGo to Flow Models ‚Üí\n\n\n\n\n Energy-Based Models (EBMs)\n\n\nCore Idea: Define an energy function over inputs; lower energy = higher probability.\nLikelihood: Unnormalized (intractable partition function).\nSampling: Very slow ‚Äî requires MCMC or Langevin dynamics.\nUse Cases: Uncertainty modeling, compositional generation.\nExample Models: Score-based EBMs\nGo to EBMs ‚Üí\n\n\n\n\n Diffusion Models\n\n\nCore Idea: Learn to reverse a gradual noise process via denoising.\nLikelihood: Approximate (via variational bound).\nSampling: Slow ‚Äî requires hundreds of reverse steps.\nUse Cases: High-resolution image and audio generation.\nExample Models: Stable Diffusion\nGo to Diffusion Models ‚Üí"
  },
  {
    "objectID": "index.html#industry-use-cases",
    "href": "index.html#industry-use-cases",
    "title": "Deep Generative Models",
    "section": "3 Industry Use Cases",
    "text": "3 Industry Use Cases\n\n\nBanking\n\n\nCustomer Service ‚Äî Autoregressive Models (e.g., GPT)\n\nFraud Detection ‚Äî Energy-Based Models\n\nOperational Efficiency ‚Äî RAG for document automation and summarization\n\nBusiness Intelligence ‚Äî VAE for anomaly detection in transaction patterns\nMarketing ‚Äî GANs for personalized message generation and segmentation\n\nIncludes deployments by JPMorgan, Mastercard, Wells Fargo, and Morgan Stanley.\nView full Banking use cases ‚Üí\n\n\n\nHealthcare\n\n\nClinical Documentation ‚Äî Autoregressive Models (e.g., GPT-4), RAG (Nuance DAX)\n\nMedical Imaging ‚Äî Diffusion Models for image enhancement\n\nDiagnostics & Triage ‚Äî VAEs for uncertainty-aware diagnosis\n\nPatient Education ‚Äî Conversational AI built on large language models\n\nDrug Discovery ‚Äî Normalizing Flows for molecular sampling and VAEs for molecule generation\n\nHighlights work by Nuance (Microsoft), Mayo Clinic, DeepMind, and Insilico Medicine.\nView full Healthcare use cases ‚Üí"
  },
  {
    "objectID": "flows.html",
    "href": "flows.html",
    "title": "Normalizing Flow Models",
    "section": "",
    "text": "In generative modeling, the objective is to learn a probability distribution over data that allows us to both generate new examples and evaluate the likelihood of observed ones. For a model to be practically useful, it must support efficient sampling and enable exact or tractable likelihood computation during training.\nA Variational Autoencoder (VAE) is a type of generative model that introduces latent variables \\(z\\), allowing the model to learn compact, structured representations of the data. VAEs are designed to support both sampling and likelihood estimation. However, computing the true marginal likelihood \\(p(x)\\) is often intractable. To address this, VAEs use variational inference to approximate the posterior \\(p(z \\mid x)\\) and optimize a surrogate objective known as the Evidence Lower Bound (ELBO). This is made possible by the reparameterization trick, which enables gradients to flow through stochastic latent variables during training.\nNormalizing flows address the limitations of VAEs by providing a way to perform exact inference and likelihood computation. They model complex data distributions using a sequence of invertible transformations applied to a simple base distribution. In this setup, a data point \\(x\\) is generated by applying a function \\(x = f(z)\\) to a latent variable \\(z\\) sampled from a simple prior (e.g., a standard Gaussian). The transformation is invertible, so \\(z\\) can be exactly recovered as \\(z = f^{-1}(x)\\). This structure enables direct access to both the data likelihood and latent variables using the change-of-variables formula.\nThis structure offers several advantages. First, each \\(x\\) maps to a unique \\(z\\), eliminating the need to marginalize over latent variables as in VAEs. Second, the change-of-variables formula enables exact computation of the likelihood, rather than approximations. Third, sampling is straightforward: draw \\(z \\sim p_Z(z)\\) from the base distribution and apply the transformation \\(x = f(z)\\).\nDespite these strengths, normalizing flows have limitations. Unlike VAEs, which can learn lower-dimensional latent representations, flows require the latent and data spaces to have equal dimensionality to preserve invertibility. This means flow-based models do not perform dimensionality reduction, which can be a disadvantage in tasks where compact representations are important.\n\n\n\nComparison of VAE and Flow-based Models\n\n\nVAEs compress data into a lower-dimensional latent space using an encoder, then reconstruct it with a decoder. Flow-based models use a single invertible transformation that keeps the same dimensionality between input and latent space. This enables exact inference and likelihood computation.\nTo understand how normalizing flows enable exact likelihood computation, we first need to explore a fundamental mathematical concept: the change-of-variable formula. This principle lies at the heart of flow models, allowing us to transform probability densities through invertible functions. We‚Äôll begin with the 1D case and build up to the multivariate formulation."
  },
  {
    "objectID": "flows.html#introduction",
    "href": "flows.html#introduction",
    "title": "Normalizing Flow Models",
    "section": "",
    "text": "In generative modeling, the objective is to learn a probability distribution over data that allows us to both generate new examples and evaluate the likelihood of observed ones. For a model to be practically useful, it must support efficient sampling and enable exact or tractable likelihood computation during training.\nA Variational Autoencoder (VAE) is a type of generative model that introduces latent variables \\(z\\), allowing the model to learn compact, structured representations of the data. VAEs are designed to support both sampling and likelihood estimation. However, computing the true marginal likelihood \\(p(x)\\) is often intractable. To address this, VAEs use variational inference to approximate the posterior \\(p(z \\mid x)\\) and optimize a surrogate objective known as the Evidence Lower Bound (ELBO). This is made possible by the reparameterization trick, which enables gradients to flow through stochastic latent variables during training.\nNormalizing flows address the limitations of VAEs by providing a way to perform exact inference and likelihood computation. They model complex data distributions using a sequence of invertible transformations applied to a simple base distribution. In this setup, a data point \\(x\\) is generated by applying a function \\(x = f(z)\\) to a latent variable \\(z\\) sampled from a simple prior (e.g., a standard Gaussian). The transformation is invertible, so \\(z\\) can be exactly recovered as \\(z = f^{-1}(x)\\). This structure enables direct access to both the data likelihood and latent variables using the change-of-variables formula.\nThis structure offers several advantages. First, each \\(x\\) maps to a unique \\(z\\), eliminating the need to marginalize over latent variables as in VAEs. Second, the change-of-variables formula enables exact computation of the likelihood, rather than approximations. Third, sampling is straightforward: draw \\(z \\sim p_Z(z)\\) from the base distribution and apply the transformation \\(x = f(z)\\).\nDespite these strengths, normalizing flows have limitations. Unlike VAEs, which can learn lower-dimensional latent representations, flows require the latent and data spaces to have equal dimensionality to preserve invertibility. This means flow-based models do not perform dimensionality reduction, which can be a disadvantage in tasks where compact representations are important.\n\n\n\nComparison of VAE and Flow-based Models\n\n\nVAEs compress data into a lower-dimensional latent space using an encoder, then reconstruct it with a decoder. Flow-based models use a single invertible transformation that keeps the same dimensionality between input and latent space. This enables exact inference and likelihood computation.\nTo understand how normalizing flows enable exact likelihood computation, we first need to explore a fundamental mathematical concept: the change-of-variable formula. This principle lies at the heart of flow models, allowing us to transform probability densities through invertible functions. We‚Äôll begin with the 1D case and build up to the multivariate formulation."
  },
  {
    "objectID": "flows.html#math-review",
    "href": "flows.html#math-review",
    "title": "Normalizing Flow Models",
    "section": "2 Math Review",
    "text": "2 Math Review\nThis section builds the mathematical foundation for understanding flow models, starting with change-of-variable and extending to multivariate transformations and Jacobians.\n\n2.1 Change of Variables in 1D\nSuppose we have a random variable \\(z\\) with a known distribution \\(p_Z(z)\\), and we define a new variable:\n\\[\nx = f(z)\n\\]\nwhere \\(f\\) is a monotonic, differentiable function with an inverse:\n\\[\nz = f^{-1}(x) = h(x)\n\\]\nOur goal is to compute the probability density function (PDF) of \\(x\\), denoted \\(p_X(x)\\), in terms of the known PDF \\(p_Z(z)\\).\n\n2.1.1 Cumulative Distribution Function (CDF)\nWe begin with the cumulative distribution function of \\(x\\):\n\\[\nF_X(x) = P(X \\leq x) = P(f(Z) \\leq x)\n\\]\nSince \\(f\\) is monotonic and invertible, this becomes:\n\\[\nP(f(Z) \\leq x) = P(Z \\leq f^{-1}(x)) = F_Z(h(x))\n\\]\n\n\n2.1.2 Deriving the PDF via Chain Rule\nTo obtain the PDF, we differentiate the CDF:\n\\[\np_X(x) = \\frac{d}{dx} F_X(x) = \\frac{d}{dx} F_Z(h(x))\n\\]\nApplying the chain rule:\n\\[\np_X(x) = F_Z'(h(x)) \\cdot h'(x) = p_Z(h(x)) \\cdot h'(x)\n\\]\n\n\n2.1.3 Rewrite in Terms of \\(z\\)\nFrom the previous step:\n\\[\np_X(x) = p_Z(h(x)) \\cdot h'(x)\n\\]\nSince \\(z = h(x)\\), we can rewrite:\n\\[\np_X(x) = p_Z(z) \\cdot h'(x)\n\\]\nNow, using the inverse function theorem, we express \\(h'(x)\\) as:\n\\[\nh'(x) = \\frac{d}{dx} f^{-1}(x) = \\frac{1}{f'(z)}\n\\]\nSo the final expression becomes:\n\\[\np_X(x) = p_Z(z) \\cdot \\left| \\frac{1}{f'(z)} \\right|\n\\]\nThe absolute value ensures the density remains non-negative, as required for any valid probability distribution.\nThis is the fundamental concept normalizing flows use to model complex distributions by transforming simple ones.\n\n\n\n2.2 Geometry: Determinants and Volume Changes\nTo further understand the multivariate change-of-variable formula, it‚Äôs helpful to first explore how linear transformations affect volume in high-dimensional spaces.\nLet \\(\\mathbf{Z}\\) be a random vector uniformly distributed in the unit cube \\([0,1]^n\\), and let \\(\\mathbf{X} = A\\mathbf{Z}\\), where \\(A\\) is a square, invertible matrix. Geometrically, the matrix \\(A\\) maps the unit hypercube to a parallelogram in 2D or a parallelotope in higher dimensions.\nThe determinant of a square matrix tells us how the transformation scales volume. For instance, if the determinant of a \\(2 \\times 2\\) matrix is 3, applying that matrix will stretch the area of a region by a factor of 3. A negative determinant indicates a reflection, meaning the transformation also flips the orientation. When measuring volume, we care about the absolute value of the determinant.\nThe volume of the resulting parallelotope is given by:\n\\[\n\\text{Volume} = |\\det(A)|\n\\]\nThis expression tells us how much the transformation \\(A\\) scales space. For example, if \\(|\\det(A)| = 2\\), the transformation doubles the volume.\nTo make this idea concrete, consider the illustration below. The left figure shows a uniform distribution over the unit square \\([0, 1]^2\\). When we apply the linear transformation \\(A = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}\\), each point in the square is mapped to a new location, stretching the square into a parallelogram. The area of this parallelogram ‚Äî and hence the volume scaling ‚Äî is given by the absolute value of the determinant \\(|\\det(A)| = |ad - bc|\\).\n\n\n\n A linear transformation maps a unit square to a parallelogram. \n\n\nThis geometric intuition becomes essential when we apply the same logic to probability densities. The area of the parallelogram equals the absolute value of the determinant, |det(A)|, indicating how the transformation scales area.\n\n\n2.3 Determinants and Probability Density\nPreviously, we saw how a linear transformation scales volume. Now we apply the same idea to probability densities ‚Äî since density is defined per unit volume, scaling the volume also affects the density.\nTo transform the density from \\(\\mathbf{Z}\\) to \\(\\mathbf{X}\\), we use the change-of-variable formula. Since \\(\\mathbf{X} = A\\mathbf{Z}\\), the inverse transformation is \\(\\mathbf{Z} = A^{-1} \\mathbf{X}\\). This tells us how to evaluate the density at \\(\\mathbf{x}\\) by ‚Äúpulling it back‚Äù through the inverse mapping. Applying the multivariate change-of-variable rule:\n\\[\np_X(\\mathbf{x}) = p_Z(W \\mathbf{x}) \\cdot \\left| \\det(W) \\right| \\quad \\text{where } W = A^{-1}\n\\]\nThis is directly analogous to the 1D change-of-variable rule:\n\\[\np_X(x) = p_Z(h(x)) \\cdot |h'(x)|\n\\]\nbut now in multiple dimensions using the determinant of the inverse transformation.\nTo make this more concrete, here‚Äôs a simple 2D example demonstrating how linear transformations affect probability density.\nLet \\(\\mathbf{Z}\\) be a random vector uniformly distributed over the unit square \\([0, 1]^2\\). Suppose we apply the transformation \\(\\mathbf{X} = A\\mathbf{Z}\\), where\n\\[\nA = \\begin{bmatrix}\n2 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\quad \\text{so that} \\quad\nW = A^{-1} =\n\\begin{bmatrix}\n\\frac{1}{2} & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\]\nThis transformation stretches the square horizontally, doubling its width while keeping the height unchanged. As a result, the area is doubled:\n\\[\n|\\det(A)| = 2 \\quad \\text{and} \\quad |\\det(W)| = \\frac{1}{2}\n\\] Since the same total probability must be spread over a larger area, the density decreases, meaning the probability per unit area is reduced due to the increased area over which the same total probability is distributed.\nNow, let‚Äôs say \\(p_Z(z) = 1\\) inside the unit square (a uniform distribution). To compute \\(p_X(\\mathbf{x})\\) at a point \\(\\mathbf{x}\\) in the transformed space, we use:\n\\[\np_X(\\mathbf{x}) = p_Z(W\\mathbf{x}) \\cdot |\\det(W)| = 1 \\cdot \\frac{1}{2} = \\frac{1}{2}\n\\]\nSo, the transformed density is halved ‚Äî the same total probability (which must remain 1) is now spread over an area that is twice as large.\n\n\n2.4 Generalizing to Nonlinear Transformations\nFor nonlinear transformations \\(\\mathbf{x} = f(\\mathbf{z})\\), the idea is similar. But instead of a constant matrix \\(A\\), we now consider the Jacobian matrix of the function \\(f\\):\n\\[\nJ_f(\\mathbf{z}) = \\frac{\\partial f}{\\partial \\mathbf{z}}\n\\]\nThe Jacobian matrix generalizes derivatives to multivariable functions, capturing how a transformation scales and rotates space locally through all partial derivatives. Its determinant tells us how much the transformation stretches or compresses space ‚Äî acting as a local volume scaling factor.\n\n\n2.5 Multivariate Change-of-Variable\nGiven an invertible transformation \\(\\mathbf{x} = f(\\mathbf{z})\\), the probability density transforms as:\n\\[\np_X(\\mathbf{x}) = p_Z(f^{-1}(\\mathbf{x})) \\cdot \\left| \\det \\left( \\frac{\\partial f^{-1}(\\mathbf{x})}{\\partial \\mathbf{x}} \\right) \\right|\n\\]\nAlternatively, in the forward form (often used during training):\n\\[\np_X(\\mathbf{x}) = p_Z(\\mathbf{z}) \\cdot \\left| \\det \\left( \\frac{\\partial f(\\mathbf{z})}{\\partial \\mathbf{z}} \\right) \\right|^{-1}\n\\]\nThis generalizes the 1D rule and enables us to compute exact likelihoods for complex distributions as long as the transformation is invertible and differentiable. This formula is pivotal in machine learning, where transformations of probability distributions are common ‚Äî such as in the implementation of normalizing flows for generative modeling."
  },
  {
    "objectID": "flows.html#flow-model",
    "href": "flows.html#flow-model",
    "title": "Normalizing Flow Models",
    "section": "3 Flow Model",
    "text": "3 Flow Model\nA normalizing flow model defines a one-to-one and reversible transformation between observed variables \\(\\mathbf{x}\\) and latent variables \\(\\mathbf{z}\\). This transformation is given by an invertible, differentiable function \\(f_\\theta\\), parameterized by \\(\\theta\\):\n\\[\n\\mathbf{x} = f_\\theta(\\mathbf{z}) \\quad \\text{and} \\quad \\mathbf{z} = f_\\theta^{-1}(\\mathbf{x})\n\\]\n\n\n\nFlow model showing forward and inverse transformations\n\n\nFigure: A flow-based model uses a forward transformation \\(f_\\theta\\) to map from latent variables (\\(\\mathbf{z}\\)) to data (\\(\\mathbf{x}\\)), and an inverse transformation \\(f_\\theta^{-1}\\) to compute likelihoods. Adapted from class notes (XCS236, Stanford).\nBecause the transformation is invertible, we can apply the change-of-variable formula to compute the exact probability of \\(\\mathbf{x}\\):\n\\[\np_X(\\mathbf{x}; \\theta) = p_Z(f_\\theta^{-1}(\\mathbf{x})) \\cdot \\left| \\det \\left( \\frac{\\partial f_\\theta^{-1}(\\mathbf{x})}{\\partial \\mathbf{x}} \\right) \\right|\n\\]\nThis makes it possible to evaluate exact likelihoods and learn the model via maximum likelihood estimation (MLE).\n\nNote: Both \\(\\mathbf{x}\\) and \\(\\mathbf{z}\\) must be continuous and have the same dimensionality since the transformation must be invertible.\n\n\n3.1 Model Architecture: A Sequence of Invertible Transformations\nThe term flow refers to the fact that we can compose multiple invertible functions to form a more expressive transformation:\n\\[\n\\mathbf{z}_m = f_\\theta^{(m)} \\circ f_\\theta^{(m-1)} \\circ \\cdots \\circ f_\\theta^{(1)}(\\mathbf{z}_0)\n\\]\nIn this setup:\n\n\\(\\mathbf{z}_0 \\sim p_Z\\) is sampled from a simple base distribution (e.g., standard Gaussian)\n\\(\\mathbf{x} = \\mathbf{z}_M\\) is the final transformed variable\nThe full transformation \\(f_\\theta\\) is the composition of \\(M\\) sequential invertible functions. Each function slightly reshapes the distribution, and together they produce a highly expressive mapping from a simple base distribution to a complex one.\n\nThe visuals below illustrate this idea from two angles. The first diagram illustrates the structure of a normalizing flow as a composition of invertible steps, while the second shows how this architecture reshapes simple distributions into complex ones through repeated transformations.\n\n\n\n Adapted from Wikipedia: Mapping simple distributions to complex ones via invertible transformations. \n\n\n\n\n\n Adapted from class notes (XCS236, Stanford), originally based on Rezende & Mohamed, 2016. \n\n\nThe density of \\(\\mathbf{x}\\) is given by the change-of-variable formula:\n\\[\np_X(\\mathbf{x}; \\theta) = p_Z(f_\\theta^{-1}(\\mathbf{x})) \\cdot \\prod_{m=1}^M \\left| \\det \\left( \\frac{\\partial (f_\\theta^{(m)})^{-1}(\\mathbf{z}_m)}{\\partial \\mathbf{z}_m} \\right) \\right|\n\\]\nThis approach allows the model to approximate highly complex distributions using simple building blocks."
  },
  {
    "objectID": "flows.html#learning-and-inference",
    "href": "flows.html#learning-and-inference",
    "title": "Normalizing Flow Models",
    "section": "4 Learning and Inference",
    "text": "4 Learning and Inference\nTraining a flow-based model is done by maximizing the log-likelihood over the dataset \\(\\mathcal{D}\\):\n\\[\n\\max_\\theta \\log p_X(\\mathcal{D}; \\theta) = \\sum_{\\mathbf{x} \\in \\mathcal{D}} \\log p_Z(f_\\theta^{-1}(\\mathbf{x})) + \\log \\left| \\det \\left( \\frac{\\partial f_\\theta^{-1}(\\mathbf{x})}{\\partial \\mathbf{x}} \\right) \\right|\n\\]\nKey advantages of normalizing flows:\n\nExact likelihoods: No approximation needed ‚Äî just apply the change-of-variable rule\nEfficient sampling: Generate new data by drawing \\(\\mathbf{z} \\sim p_Z\\) and computing \\(\\mathbf{x} = f_\\theta(\\mathbf{z})\\)\nLatent inference: Invert \\(f_\\theta\\) to compute latent codes \\(\\mathbf{z} = f_\\theta^{-1}(\\mathbf{x})\\), without needing a separate encoder\n\n\n4.1 Computational Considerations\nOne challenge in training normalizing flow models is that computing the exact likelihood requires evaluating the determinant of the Jacobian matrix of the transformation:\n\nFor a transformation \\(f : \\mathbb{R}^n \\to \\mathbb{R}^n\\), the Jacobian is an \\(n \\times n\\) matrix.\nComputing its determinant has a cost of \\(\\mathcal{O}(n^3)\\), which is computationally expensive during training ‚Äî especially in high dimensions.\n\n\n4.1.1 Key Insight\nTo make normalizing flows scalable, we design transformations where the Jacobian has a special structure that makes the determinant easy to compute.\nFor example: - If the Jacobian is a triangular matrix, the determinant is just the product of the diagonal entries, which can be computed in \\(\\mathcal{O}(n)\\) time. - This works because in a triangular matrix, all the off-diagonal elements are zero ‚Äî so the determinant simplifies significantly.\nIn practice, flow models like RealNVP and MAF are designed so that each output dimension \\(x_i\\) depends only on some subset of the input dimensions \\(z_{\\leq i}\\) (for lower triangular structure) or \\(z_{\\geq i}\\) (for upper triangular structure). This results in a Jacobian of the form:\n\\[\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{z}} =\n\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial z_1} & 0 & \\cdots & 0 \\\\\n\\ast & \\frac{\\partial f_2}{\\partial z_2} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\ast & \\ast & \\cdots & \\frac{\\partial f_n}{\\partial z_n}\n\\end{pmatrix}\n\\]\nBecause of this triangular structure, computing the determinant becomes as simple as multiplying the diagonal terms:\n\\[\n\\det(J) = \\prod_{i=1}^{n} \\frac{\\partial f_i}{\\partial z_i}\n\\]\nThis is why many modern flow models rely on coupling layers or autoregressive masking: they preserve invertibility and enable efficient, exact likelihood computation."
  },
  {
    "objectID": "flows.html#types-of-flow-architectures",
    "href": "flows.html#types-of-flow-architectures",
    "title": "Normalizing Flow Models",
    "section": "5 Types of Flow Architectures",
    "text": "5 Types of Flow Architectures\nThis section introduces common architectural families used in normalizing flows, highlighting their core ideas, strengths, and limitations.\n\n5.1 Elementwise Flows\n\nIdea: Apply a simple invertible function to each variable independently.\nExamples: Leaky ReLU, Softplus, ELU.\nStrengths: Extremely fast; easy to implement; analytically tractable.\nLimitations: Cannot model interactions or dependencies between variables.\n\n\n\n5.2 Linear Flows\n\nIdea: Apply a linear transformation using an invertible matrix (e.g., permutation, rotation, LU decomposition).\nExamples: Glow‚Äôs 1x1 Convolution, LU flows.\nStrengths: Efficiently models global dependencies; can be used to permute variables.\nLimitations: Limited expressiveness when used alone.\n\n\n\n5.3 Coupling Flows\n\nIdea: Split the input into two parts. One half remains unchanged while the other is transformed based on it.\nExamples: NICE (additive), RealNVP (affine).\nStrengths: Easy to invert and compute Jacobians; scalable to high dimensions.\nLimitations: Requires stacking multiple layers to mix information across all dimensions.\n\n\n\n5.4 Autoregressive Flows\n\nIdea: Model the transformation of each variable conditioned on the previous ones in a fixed order.\nExamples: Masked Autoregressive Flow (MAF), Inverse Autoregressive Flow (IAF).\nStrengths: Highly expressive; models arbitrary dependencies.\nLimitations: Slower sampling or density evaluation depending on flow direction.\n\n\n\n5.5 Residual Flows\n\nIdea: Add residual connections while enforcing invertibility (e.g., using constraints on Jacobian eigenvalues).\nExamples: Planar flows, Radial flows, Residual Flows (Behrmann et al.).\nStrengths: Flexible and capable of complex transformations.\nLimitations: May require care to ensure invertibility; harder to train.\n\n\n\n5.6 Continuous Flows\n\nIdea: Model the transformation as the solution to a differential equation parameterized by a neural network.\nExamples: Neural ODEs, FFJORD.\nStrengths: Highly flexible; enables continuous-time modeling.\nLimitations: Computationally expensive; uses ODE solvers during training and inference.\n\n\nThese architectures can be mixed and matched in real-world models to balance expressiveness, efficiency, and tractability. Each comes with trade-offs, and their selection often depends on the task and data at hand.\nIn the rest of this article, we focus on Coupling Flows, briefly introducing NICE and then diving deeper into the structure, intuition, and implementation details of RealNVP.\n\n\n5.7 NICE: Nonlinear Independent Components Estimation\nThe NICE (Nonlinear Independent Components Estimation) model, introduced by Laurent Dinh, David Krueger, and Yoshua Bengio in 2014, is a foundational work in the development of normalizing flows.\nIt provides a framework for transforming complex high-dimensional data into a simpler latent space (often a standard Gaussian), enabling both exact likelihood estimation and sampling ‚Äî two fundamental goals in generative modeling.\n\n5.7.1 Core Concepts\n\nInvertible Transformations:\nNICE constructs a chain of invertible functions to map inputs to latent variables. This ensures that both the forward and inverse transformations are tractable.\nAdditive Coupling Layers:\nThe model partitions the input into two parts and applies an additive transformation to one part using a function of the other. This design yields a triangular Jacobian with determinant 1, making log-likelihood computation efficient.\nVolume-Preserving Mapping:\nBecause additive coupling layers do not scale the space, NICE preserves volume ‚Äî i.e., the Jacobian determinant is exactly 1. While this limits expressiveness, it simplifies training and inference.\nScaling Layer (Optional):\nThe original NICE paper includes an optional scaling layer at the end to allow some volume change per dimension.\nExact Log-Likelihood:\nUnlike VAEs or GANs, which rely on approximations, NICE enables exact evaluation of the log-likelihood, making it a fully probabilistic, likelihood-based model.\n\n\n\n5.7.2 Additive Coupling Layer\nTo make the transformation invertible and computationally efficient, NICE splits the input vector into two parts. One part is kept unchanged, while the other part is modified using a function of the unchanged part. This way, we can easily reverse the process because we always know what was kept intact.\nLet‚Äôs partition the input \\(\\mathbf{z} \\in \\mathbb{R}^n\\) into two subsets: \\(\\mathbf{z}_{1:d}\\) and \\(\\mathbf{z}_{d+1:n}\\) for some \\(1 \\leq d &lt; n\\).\n\nForward Mapping \\(\\mathbf{z} \\mapsto \\mathbf{x}\\):\n\n\\[\n\\begin{aligned}\n\\mathbf{x}_{1:d} &= \\mathbf{z}_{1:d} \\quad \\text{(identity transformation)} \\\\\n\\mathbf{x}_{d+1:n} &= \\mathbf{z}_{d+1:n} + m_\\theta(\\mathbf{z}_{1:d})\n\\end{aligned}\n\\]\nwhere \\(m_\\theta(\\cdot)\\) is a neural network with parameters \\(\\theta\\), \\(d\\) input units, and \\(n - d\\) output units.\n\nInverse Mapping \\(\\mathbf{x} \\mapsto \\mathbf{z}\\):\n\n\\[\n\\begin{aligned}\n\\mathbf{z}_{1:d} &= \\mathbf{x}_{1:d} \\quad \\text{(identity transformation)} \\\\\n\\mathbf{z}_{d+1:n} &= \\mathbf{x}_{d+1:n} - m_\\theta(\\mathbf{x}_{1:d})\n\\end{aligned}\n\\]\n\nJacobian of the forward mapping:\n\nThe Jacobian matrix captures how much the transformation stretches or compresses space. Because the unchanged subset passes through as-is and the transformation is purely additive (no scaling), the Jacobian is triangular with 1s on the diagonal ‚Äî so its determinant is 1 ‚Äî meaning the transformation preserves volume.\n\\[\nJ = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{z}} =\n\\begin{pmatrix}\nI_d & 0 \\\\\n\\frac{\\partial m_\\theta}{\\partial \\mathbf{z}_{1:d}} & I_{n-d}\n\\end{pmatrix}\n\\]\n\\[\n\\det(J) = 1\n\\]\nHence, additive coupling is a volume-preserving transformation.\n\n\n5.7.3 Rescaling Layer\nTo overcome the limitation of fixed volume, NICE adds a diagonal scaling transformation at the end, allowing the model to contract or expand space. This is not part of the coupling layers, but is crucial to increase flexibility.\n\nForward Mapping:\n\n\\[\nx_i = s_i z_i \\quad \\text{with} \\quad s_i &gt; 0\n\\]\n\nInverse Mapping:\n\n\\[\nz_i = \\frac{x_i}{s_i}\n\\]\n\nJacobian:\n\n\\[\nJ = \\text{diag}(\\mathbf{s})\n\\quad \\Rightarrow \\quad\n\\det(J) = \\prod_{i=1}^n s_i\n\\]\nHowever, the volume-preserving property of NICE limits its expressiveness. RealNVP extends this idea by introducing affine coupling layers that enable volume changes during transformation.\n\n\n\n5.8 Real-NVP: Non-Volume Preserving Extension of NICE\nReal-NVP (Dinh et al., 2017) extends NICE by introducing a scaling function that allows the model to change volume, enabling more expressive transformations. This is achieved using affine coupling layers that apply learned scaling and translation functions to part of the input while keeping the rest unchanged.\n\n\n\n Visualization of a single affine coupling layer in RealNVP. The identity path and affine transform structure allow exact inversion and efficient computation. \n\n\nWe partition the input \\(\\mathbf{z} \\in \\mathbb{R}^n\\) into two subsets: \\(\\mathbf{z}_{1:d}\\) and \\(\\mathbf{z}_{d+1:n}\\).\n\nForward Mapping \\(\\mathbf{z} \\mapsto \\mathbf{x}\\):\n\n\\[\n\\begin{aligned}\n\\mathbf{x}_{1:d} &= \\mathbf{z}_{1:d} \\quad \\text{(identity transformation)} \\\\\\\\\n\\mathbf{x}_{d+1:n} &= \\mathbf{z}_{d+1:n} \\odot \\exp(\\alpha_\\theta(\\mathbf{z}_{1:d})) + \\mu_\\theta(\\mathbf{z}_{1:d})\n\\end{aligned}\n\\]\nHere, \\(\\boldsymbol{\\alpha}_\\theta(\\cdot)\\) and \\(\\boldsymbol{\\mu}_\\theta(\\cdot)\\) are neural networks with parameters \\(\\theta\\) that take the unchanged subset \\(\\mathbf{z}_{1:d}\\) as input and produce scale and shift parameters, respectively, for the transformed subset \\(\\mathbf{z}_{d+1:n}\\). These functions enable flexible, learnable affine transformations while preserving invertibility.\n\nInverse Mapping \\(\\mathbf{x} \\mapsto \\mathbf{z}\\):\n\n\\[\n\\begin{aligned}\n\\mathbf{z}_{1:d} &= \\mathbf{x}_{1:d} \\quad \\text{(identity transformation)} \\\\\\\\\n\\mathbf{z}_{d+1:n} &= \\left( \\mathbf{x}_{d+1:n} - \\mu_\\theta(\\mathbf{x}_{1:d}) \\right) \\odot \\exp(-\\alpha_\\theta(\\mathbf{x}_{1:d}))\n\\end{aligned}\n\\]\nThe inverse mapping recovers the latent variable \\(\\mathbf{z}\\) from the data \\(\\mathbf{x}\\). The first subset \\(\\mathbf{x}_{1:d}\\) remains unchanged and directly becomes \\(\\mathbf{z}_{1:d}\\). To reconstruct \\(\\mathbf{z}_{d+1:n}\\), we first subtract the shift \\(\\boldsymbol{\\mu}_\\theta(\\mathbf{x}_{1:d})\\) from \\(\\mathbf{x}_{d+1:n}\\), and then apply an elementwise rescaling using \\(\\exp(-\\boldsymbol{\\alpha}_\\theta(\\mathbf{x}_{1:d}))\\). This inversion relies on the same neural networks used in the forward pass and ensures that the transformation is exactly reversible.\n\nJacobian of Forward Mapping:\n\n\\[\nJ = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{z}} =\n\\begin{pmatrix}\nI_d & 0 \\\\\\\\\n\\frac{\\partial \\mathbf{x}_{d+1:n}}{\\partial \\mathbf{z}_{1:d}} & \\operatorname{diag}\\left(\\exp(\\alpha_\\theta(\\mathbf{z}_{1:d}))\\right)\n\\end{pmatrix}\n\\]\nThe Jacobian matrix of the RealNVP forward transformation has a special block structure due to the design of the affine coupling layer:\n\nUpper left block: \\(\\mathbf{I}_d\\)\nThis corresponds to the partial derivatives of \\(\\mathbf{x}_{1:d}\\) with respect to \\(\\mathbf{z}_{1:d}\\). Since the first \\(d\\) variables are passed through unchanged (\\(\\mathbf{x}_{1:d} = \\mathbf{z}_{1:d}\\)), their derivatives form an identity matrix.\nUpper right block: \\(0\\)\nThese derivatives are zero because \\(\\mathbf{x}_{1:d}\\) does not depend on \\(\\mathbf{z}_{d+1:n}\\) at all ‚Äî they‚Äôre completely decoupled.\nLower right block: (diagonal)\nEach element of \\(\\mathbf{x}_{d+1:n}\\) is scaled elementwise by \\(\\exp\\left(\\left[\\alpha_\\theta(\\mathbf{z}_{1:d})\\right]_i\\right)\\). This means the Jacobian of this part is a diagonal matrix, where each diagonal entry is the corresponding scale factor.\nLower left block:\nThis part can contain non-zero values because \\(\\mathbf{x}_{d+1:n}\\) depends on \\(\\mathbf{z}_{1:d}\\) via the neural networks. But thanks to the triangular structure of the Jacobian, we don‚Äôt need this block to compute the determinant.\n\n\n\n\n Jacobian of the RealNVP forward transformation. Upper triangular structure arises because the first subset is unchanged, while the second is scaled and shifted based on the first. \n\n\n\n5.8.1 Why This Structure Matters\nBecause the Jacobian is triangular, its determinant is simply the product of the diagonal entries.\n\\[\n\\det(J) = \\prod_{i=d+1}^{n} \\exp\\left( \\alpha_\\theta(\\mathbf{z}_{1:d})_i \\right)\n= \\exp\\left( \\sum_{i=d+1}^{n} \\alpha_\\theta(\\mathbf{z}_{1:d})_i \\right)\n\\]\nIn log-space, this becomes a sum:\n\\[\n\\log \\det(J) = \\sum_{i=d+1}^{n} \\alpha_\\theta(\\mathbf{z}_{1:d})_i\n\\]\nThis makes the computation of log-likelihoods fast and tractable.\nTaking the product of the diagonal entries gives us a measure of how much the transformation expands or contracts local volume. If the determinant is greater than 1, the transformation expands space; if it‚Äôs less than 1, it contracts space. Since the determinant is not fixed, RealNVP performs a non-volume preserving transformation ‚Äî allowing it to model more complex distributions than NICE, which preserves volume by design.\n\n\n5.8.2 Stacking Coupling Layers\nEach coupling layer only transforms part of the input. To ensure that every dimension is eventually updated, RealNVP stacks multiple coupling layers and alternates the masking pattern between them.\n\nIn one layer, the first half is fixed, and the second half is transformed.\nIn the next layer, the roles are reversed.\n\nThis alternating structure ensures: - All input dimensions are updated across layers - The full transformation remains invertible - The total log-determinant is the sum of the log-determinants of each layer\n\n\n5.8.3 RealNVP in Action (Two Moons)\nThe following plots illustrate how RealNVP transforms data in practice:\n\n\n\n Top-left: Original two-moons data (X)\nTop-right: Encoded latent space (Z) Bottom-left: Latent samples from base distribution\nBottom-right: Generated samples mapped back to (X) space\n\n\n\n\n\n5.8.4 Summary\nTo recap the key distinctions between NICE and RealNVP, here‚Äôs a side-by-side comparison:\n\n\n\n\n\n\n\n\nAspect\nNICE\nRealNVP\n\n\n\n\nType of coupling\nAdditive\nAffine (scaling + shift)\n\n\nVolume change\nOnly possible with rescaling layer\nBuilt into each coupling layer\n\n\nJacobian determinant\n1 (in coupling layers)\nVaries (depends on learned scale)\n\n\nExpressiveness\nLimited (volume-preserving layers)\nHigher (learns scale & shift)\n\n\nLog-likelihood\nExact\nExact"
  },
  {
    "objectID": "flows.html#try-it-yourself-flow-model-in-pytorch",
    "href": "flows.html#try-it-yourself-flow-model-in-pytorch",
    "title": "Normalizing Flow Models",
    "section": "6 üß™ Try It Yourself: Flow Model in Pytorch",
    "text": "6 üß™ Try It Yourself: Flow Model in Pytorch\nYou can explore a minimal PyTorch implementation of a normalizing flow model:\n\nüìò View Notebook on GitHub\nüöÄ Run in Google Colab"
  },
  {
    "objectID": "flows.html#references",
    "href": "flows.html#references",
    "title": "Normalizing Flow Models",
    "section": "7 References",
    "text": "7 References\n[1] Stanford CS236 Notes. ‚ÄúNormalizing Flows‚Äù\n[2] UT Austin Calculus Notes. ‚ÄúJacobian and Change of Variables‚Äù\n[3] Danilo Jimenez Rezende, and Shakir Mohamed. ‚ÄúVariational Inference with Normalizing Flows‚Äù\n[4] Kobyzev, Prince, and Brubaker. ‚ÄúNormalizing Flows: An Introduction and Review of Current Methods‚Äù\n[5] Wikipedia. ‚ÄúNormalizing Flow‚Äù"
  },
  {
    "objectID": "flows.html#further-reading",
    "href": "flows.html#further-reading",
    "title": "Normalizing Flow Models",
    "section": "8 Further Reading",
    "text": "8 Further Reading\n[1] George Papamakarios et al.¬†‚ÄúNormalizing Flows for Probabilistic Modeling and Inference‚Äù\n[2] Lilian Weng. ‚ÄúFlow-based Models‚Äù\n[3] Eric Jang. ‚ÄúNormalizing Flows Tutorial ‚Äì Part 1‚Äù\n[4] Eric Jang. ‚ÄúNormalizing Flows Tutorial ‚Äì Part 2‚Äù"
  },
  {
    "objectID": "normalizing_flow_pytorch.html",
    "href": "normalizing_flow_pytorch.html",
    "title": "RealNVP Model in PyTorch",
    "section": "",
    "text": "This notebook provides a simple implementation of a RealNVP flow model.\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import TensorDataset, DataLoader, random_split\nfrom torch.distributions import MultivariateNormal\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.datasets import make_moons\n\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nprint(f\"Using device: {device}\")\n\nUsing device: cuda\n\n\n\n1 Create a Normalize the Two Moons Dataset\n\n# Generate the two moons dataset\nn_samples = 30000\ndata, _ = make_moons(n_samples=n_samples, noise=0.05)\ndata = data.astype(np.float32)\n\n# Normalize the dataset\nscaler = StandardScaler()\nnormalized_data = scaler.fit_transform(data)\n\n# Convert to PyTorch tensor and move to device\nnormalized_data = torch.tensor(normalized_data, dtype=torch.float32).to(device)\n\n# Visualize the data\nplt.figure(figsize=(6, 6))\nplt.scatter(normalized_data[:, 0].cpu(), normalized_data[:, 1].cpu(), s=1, c='green')\nplt.title(\"Normalized Two Moons Dataset\")\nplt.axis(\"equal\")\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nclass CouplingMLP(nn.Module):\n    def __init__(self, input_dim, hidden_dim=256):\n        super().__init__()\n\n        self.net = nn.Sequential(\n            nn.Linear(input_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU(),\n        )\n\n        # Scale output: initialized near zero with tanh for stability\n        self.scale = nn.Linear(hidden_dim, input_dim)\n        self.translate = nn.Linear(hidden_dim, input_dim)\n\n        # Apply Xavier initialization\n        for m in self.modules():\n            if isinstance(m, nn.Linear):\n                nn.init.xavier_uniform_(m.weight)\n                if m.bias is not None:\n                    nn.init.zeros_(m.bias)\n\n    def forward(self, x):\n        h = self.net(x)\n        s = torch.tanh(self.scale(h)) * 2.0  # bounded scaling\n        t = self.translate(h)\n        return s, t\n\n\nclass RealNVP(nn.Module):\n    def __init__(self, input_dim=2, num_coupling_layers=6):\n        super().__init__()\n        self.input_dim = input_dim\n        self.num_coupling_layers = num_coupling_layers\n\n        # Prior distribution in latent space\n        self.prior = torch.distributions.MultivariateNormal(\n            torch.zeros(input_dim).to(device),\n            torch.eye(input_dim).to(device)\n        )\n\n        # Alternating binary masks, e.g., [0,1], [1,0], ...\n        self.masks = torch.tensor(\n            [[0, 1], [1, 0]] * (num_coupling_layers // 2),\n            dtype=torch.float32\n        ).to(device)\n\n        # Create coupling layers\n        self.coupling_layers = nn.ModuleList([\n            CouplingMLP(input_dim=input_dim) for _ in range(num_coupling_layers)\n        ])\n\n    def forward(self, x, reverse=False):\n        \"\"\"\n        If reverse=False: maps data ‚Üí latent (x ‚Üí z)\n        If reverse=True:  maps latent ‚Üí data (z ‚Üí x)\n        \"\"\"\n        log_det = torch.zeros(x.shape[0], device=x.device)\n        direction = -1 if not reverse else 1\n        layers = range(self.num_coupling_layers)[::direction]\n\n        for i in layers:\n            mask = self.masks[i]\n            x_masked = x * mask\n            s, t = self.coupling_layers[i](x_masked)\n\n            s = s * (1 - mask)\n            t = t * (1 - mask)\n\n            if reverse:\n                x = (x - t) * torch.exp(-s) * (1 - mask) + x_masked\n            else:\n                x = (x * torch.exp(s) + t) * (1 - mask) + x_masked\n                log_det += torch.sum(s, dim=1)\n\n        return x, log_det\n\n    def log_prob(self, x):\n        \"\"\"\n        Log probability of input x under the model.\n        \"\"\"\n        z, log_det = self.forward(x, reverse=False)\n        log_prob_z = self.prior.log_prob(z)\n        return log_prob_z + log_det\n\n    def loss(self, x):\n        \"\"\"\n        Negative log-likelihood loss.\n        \"\"\"\n        return -self.log_prob(x).mean()\n\n\nbatch_size = 256\nepochs = 100\nlearning_rate = 1e-4\n\n\ndataset = TensorDataset(normalized_data)\ntrain_loader = DataLoader(dataset, batch_size=batch_size, shuffle=True)\n\n\nmodel = RealNVP(input_dim=2, num_coupling_layers=6).to(device)\noptimizer = optim.Adam(model.parameters(), lr=learning_rate)\n\n\nlosses = []\n\nfor epoch in range(epochs):\n    epoch_loss = 0.0\n    model.train()\n\n    for batch in train_loader:\n        x = batch[0].to(device)\n\n        optimizer.zero_grad()\n        loss = model.loss(x)\n        loss.backward()\n        optimizer.step()\n\n        epoch_loss += loss.item() * x.size(0)\n\n    avg_loss = epoch_loss / len(train_loader.dataset)\n    losses.append(avg_loss)\n    if (epoch + 1) % 10 == 0:\n        print(f\"Epoch [{epoch+1}/{epochs}], Loss: {avg_loss:.4f}\")\n\nEpoch [10/100], Loss: 1.3349\nEpoch [20/100], Loss: 1.2672\nEpoch [30/100], Loss: 1.2408\nEpoch [40/100], Loss: 1.2296\nEpoch [50/100], Loss: 1.2191\nEpoch [60/100], Loss: 1.2145\nEpoch [70/100], Loss: 1.1950\nEpoch [80/100], Loss: 1.1911\nEpoch [90/100], Loss: 1.1978\nEpoch [100/100], Loss: 1.1867\n\n\n\nplt.figure(figsize=(8, 5))\nplt.plot(losses, label=\"Training Loss\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"Negative Log-Likelihood\")\nplt.title(\"RealNVP Training Loss\")\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nmodel.eval()\nwith torch.no_grad():\n    z, _ = model(normalized_data, reverse=False)\n\n\nwith torch.no_grad():\n    z_samples = model.prior.sample((3000,))\n    x_samples, _ = model(z_samples, reverse=True)\n\n\nf, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# Original data\naxes[0, 0].scatter(normalized_data[:, 0].cpu(), normalized_data[:, 1].cpu(), s=1, c='green')\naxes[0, 0].set_title(\"Original Data (X)\")\naxes[0, 0].axis(\"equal\")\n\n# Latent representation of data\naxes[0, 1].scatter(z[:, 0].cpu(), z[:, 1].cpu(), s=1, c='blue')\naxes[0, 1].set_title(\"Encoded Latent Space (Z)\")\naxes[0, 1].axis(\"equal\")\n\n# Random latent samples\naxes[1, 0].scatter(z_samples[:, 0].cpu(), z_samples[:, 1].cpu(), s=1, c='orange')\naxes[1, 0].set_title(\"Sampled Latent Z\")\naxes[1, 0].axis(\"equal\")\n\n# Transformed back to data\naxes[1, 1].scatter(x_samples[:, 0].cpu(), x_samples[:, 1].cpu(), s=1, c='red')\naxes[1, 1].set_title(\"Generated Samples (X)\")\naxes[1, 1].axis(\"equal\")\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "gen-ai-use-cases/healthcare-use-cases.html",
    "href": "gen-ai-use-cases/healthcare-use-cases.html",
    "title": "Generative AI Use Cases in Healthcare",
    "section": "",
    "text": "Generative AI is accelerating transformation in healthcare by automating documentation, enhancing diagnostic imaging, improving drug discovery, and supporting clinical and administrative workflows. Below are key use cases currently being deployed by healthcare systems and life sciences firms."
  },
  {
    "objectID": "gen-ai-use-cases/healthcare-use-cases.html#summary-of-use-cases",
    "href": "gen-ai-use-cases/healthcare-use-cases.html#summary-of-use-cases",
    "title": "Generative AI Use Cases in Healthcare",
    "section": "1 üìã Summary of Use Cases",
    "text": "1 üìã Summary of Use Cases\n\n\n\n\n\n\n\n\nUse Case Area\nExamples\nBenefits\n\n\n\n\nClinical Documentation\nNuance DAX, AWS HealthScribe\nReduced burden, faster note capture\n\n\nMedical Imaging & Diagnostics\nDeepMind, MIT CSAIL\nEnhanced resolution, rare disease training\n\n\nDrug Discovery & Molecule Design\nInsilico, BenevolentAI\nFaster R&D cycles, AI-generated molecules\n\n\nPatient Communication\nMayo Copilot, Ada Health\nSimplified education, automated triage\n\n\nAdmin Workflow Automation\nMedLM, Abridge\nProcess improvement, reduced manual work"
  },
  {
    "objectID": "gen-ai-use-cases/healthcare-use-cases.html#use-cases-in-healthcare",
    "href": "gen-ai-use-cases/healthcare-use-cases.html#use-cases-in-healthcare",
    "title": "Generative AI Use Cases in Healthcare",
    "section": "2 Use Cases in Healthcare",
    "text": "2 Use Cases in Healthcare\n\n2.1 ü©∫ Clinical Documentation\n\n\n\n\n\n\nWhy it matters:\nGenerative AI is significantly reducing the administrative burden on clinicians by automating the creation of clinical notes and summaries. AI tools can transcribe doctor-patient conversations, extract relevant medical details, and generate structured notes in real time or post-visit.\n\n\n\nExamples:\n- Nuance DAX Copilot (Microsoft): Automatically generates clinical notes during consultations, reducing documentation time for physicians.\n- AWS HealthScribe: Extracts structured data and generates medical summaries from recorded conversations between patients and providers.\n\n\n2.2 üß† Medical Imaging and Diagnostics\n\n\n\n\n\n\nWhy it matters:\nGenerative models such as GANs and diffusion are being used to enhance medical images, synthesize missing views, and even generate realistic training data for rare conditions. These techniques improve diagnostic quality and accelerate model development.\n\n\n\nExamples:\n- Google DeepMind: Uses generative models to enhance resolution in retinal scans and chest X-rays.\n- MIT CSAIL: Trains diagnostic AI systems using synthetic images generated via diffusion models, improving accuracy for rare diseases.\n\n\n2.3 üíä Drug Discovery and Molecular Design\n\n\n\n\n\n\nWhy it matters:\nPharmaceutical companies and AI research labs are using GenAI to generate novel molecular structures that satisfy biological and chemical constraints. This reduces the time and cost of early-stage drug discovery.\n\n\n\nExamples:\n- Insilico Medicine: Uses generative chemistry platforms to propose new drug candidates and recently advanced one into Phase II trials.\n- BenevolentAI: Uses AI models to generate molecules with desired properties based on disease pathways and target proteins.\n\n\n2.4 üó£Ô∏è Patient Communication and Education\n\n\n\n\n\n\nWhy it matters:\nHealthcare providers are using GenAI to generate personalized educational materials, explain complex medical conditions in plain language, and respond to patient questions through virtual assistants.\n\n\n\nExamples:\n- Mayo Clinic and Microsoft Copilot: Exploring AI to generate patient-friendly summaries of lab results and discharge instructions.\n- Ada Health: Uses generative agents to guide patients through symptom checking and triage using everyday language.\n\n\n2.5 üè• Administrative Workflow Automation\n\n\n\n\n\n\nWhy it matters:\nHospitals and health systems are adopting GenAI to streamline operational processes such as prior authorization, billing, appeals, and scheduling. This improves staff productivity and reduces manual paperwork.\n\n\n\nExamples:\n- Google MedLM: Supports automation of prior authorization workflows and claim denials through natural language understanding and document generation.\n- Abridge: Not only transcribes medical conversations, but also classifies, summarizes, and codes them for billing and documentation purposes."
  },
  {
    "objectID": "gen-ai-use-cases/healthcare-use-cases.html#key-takeaways",
    "href": "gen-ai-use-cases/healthcare-use-cases.html#key-takeaways",
    "title": "Generative AI Use Cases in Healthcare",
    "section": "3 üßæ Key Takeaways",
    "text": "3 üßæ Key Takeaways\n\nGenAI in healthcare is moving from pilots to production, especially in clinical documentation and imaging.\nHospitals, insurers, and biotech firms are exploring AI-powered assistants to streamline manual workflows and improve decision support.\nPatient-facing use cases like education and triage are opening the door for more accessible, scalable care delivery."
  },
  {
    "objectID": "gen-ai-use-cases/healthcare-use-cases.html#references",
    "href": "gen-ai-use-cases/healthcare-use-cases.html#references",
    "title": "Generative AI Use Cases in Healthcare",
    "section": "4 üìö References",
    "text": "4 üìö References\n[1] Nuance Communications. (2024). Automatically Document Care with DAX Copilot. Retrieved from https://www.nuance.com/DAXCopilot.html\n[2] Amazon Web Services. (2024). Generate Clinical Notes with AI ‚Äì AWS HealthScribe. Retrieved from https://aws.amazon.com/healthscribe/\n[3] DeepMind. (2023). Developing Reliable AI Tools for Healthcare. Retrieved from https://deepmind.google/discover/blog/codoc-developing-reliable-ai-tools-for-healthcare/\n[4] Insilico Medicine. (2023). First Generative AI Drug Begins Phase II Trials with Patients. Retrieved from https://insilico.com/blog/first_phase2\n[5] BenevolentAI. (2023). AI Drug Discovery. Retrieved from https://www.benevolent.com/\n[6] Microsoft News Center. (2023). Mayo Clinic to Deploy and Test Microsoft Generative AI Tools. Retrieved from https://news.microsoft.com/source/2023/09/28/mayo-clinic-to-deploy-and-test-microsoft-generative-ai-tools/\n[7] Ada Health. (2023). Improving Digital Triage with AI. Retrieved from https://about.ada.com/improving-patient-pathways-with-ada-digital-triage/\n[8] Abridge. (2023). AI Scribe Giant Abridge Touts Pittsburgh Roots. Retrieved from https://www.axios.com/local/pittsburgh/2025/03/10/ai-scribe-abridge-pittsburgh-roots\n[9] Financial Times. (2024). Healthcare Turns to AI for Medical Note-Taking ‚ÄòScribes‚Äô. Retrieved from https://www.ft.com/content/5c356658-6db4-47c1-940b-b2e3cf3a51f3"
  },
  {
    "objectID": "diffusion.html#u-net-architecture-for-denoising",
    "href": "diffusion.html#u-net-architecture-for-denoising",
    "title": "Diffusion Models",
    "section": "5 U-Net Architecture for Denoising",
    "text": "5 U-Net Architecture for Denoising\nThe network \\(\\epsilon_\\theta(x_t, t)\\) is typically implemented as a U-Net, which takes:\n\nA noisy image \\(x_t\\)\nA timestep \\(t\\), encoded using sinusoidal or learned embeddings\n\nIt outputs the predicted noise \\(\\epsilon\\), allowing the model to reverse the diffusion process.\nThe U-Net architecture is particularly effective in diffusion models because it preserves the spatial resolution of the input throughout the network. Unlike VAEs, which compress the input into a lower-dimensional latent space, the U-Net uses skip connections to pass fine-grained information directly from downsampling to upsampling layers. This helps preserve image detail and texture throughout the denoising process.\n\n5.1 Key components of the U-Net used in diffusion models:\n\nThe input is a noisy image (e.g., shape \\(64 \\times 64 \\times 3\\)) that we wish to denoise.\nA second input provides the noise variance (or timestep), passed through a sinusoidal embedding function.\nThe time embedding is upsampled and concatenated with the noisy image along the channel dimension.\nThe combined input is passed through:\n\nA downsampling path composed of DownBlocks, which increase the number of channels while reducing spatial dimensions.\nResidual blocks at the bottleneck that help learn deeper representations.\nAn upsampling path composed of UpBlocks, which mirror the downsampling layers.\nSkip connections between corresponding down and up blocks to preserve spatial detail.\n\nThe output is produced by a final \\(1 \\times 1\\) convolutional layer initialized to zeros.\n\nThis structure allows the model to iteratively refine and denoise its estimate of the clean image across reverse steps.\n\n\n\nThe denoising model receives the noisy input \\(x_t\\) and a time embedding \\(t\\), and predicts the noise \\(\\epsilon_\\theta(x_t, t)\\) that was added at step \\(t\\).\n\n\nAdapted from Stanford CS236: Deep Generative Models (Winter 2023).\n\n\n\n5.2 Takeaways\n\nThe ELBO provides a tractable lower bound on the data likelihood \\(\\log p_\\theta(x_0)\\), and serves as the theoretical training objective.\nIt decomposes into loss terms that align the learned reverse process with the fixed forward noising process, step by step.\nIn practice (as in DDPM), training is simplified to minimizing the mean squared error between the true noise \\(\\epsilon\\) and the predicted noise \\(\\epsilon_\\theta(x_t, t)\\)."
  }
]