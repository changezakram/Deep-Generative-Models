<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Normalizing Flow Models – Changez Akram</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ebm.html" rel="next">
<link href="./coming-soon.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./vae.html">Deep Generative Models</a></li><li class="breadcrumb-item"><a href="./flows.html">Normalizing Flows</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Changez Akram</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Deep Generative Models</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./vae.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Variational Autoencoders (VAEs)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Generative Adversarial Networks (GANs) [Coming Soon]</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Autoregressive Models [Coming Soon]</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./flows.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Normalizing Flows</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ebm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Energy-Based Models (EBMs)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Diffusion Models [Coming Soon]</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model Evaluation [Coming Soon]</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">Large Language Models</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Word Embedding [Coming Soon]</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Recurrent Neural Networks [Coming Soon]</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sequence-to-Sequence Models [Coming Soon]</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Transformers [Coming Soon]</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coming-soon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">LLM Evaluation [Coming Soon]</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#math-review" id="toc-math-review" class="nav-link" data-scroll-target="#math-review"><span class="header-section-number">2</span> Math Review</a></li>
  <li><a href="#flow-model" id="toc-flow-model" class="nav-link" data-scroll-target="#flow-model"><span class="header-section-number">3</span> Flow Model</a></li>
  <li><a href="#learning-and-inference" id="toc-learning-and-inference" class="nav-link" data-scroll-target="#learning-and-inference"><span class="header-section-number">4</span> Learning and Inference</a></li>
  <li><a href="#types-of-flow-architectures" id="toc-types-of-flow-architectures" class="nav-link" data-scroll-target="#types-of-flow-architectures"><span class="header-section-number">5</span> Types of Flow Architectures</a></li>
  <li><a href="#try-it-yourself-flow-model-in-pytorch" id="toc-try-it-yourself-flow-model-in-pytorch" class="nav-link" data-scroll-target="#try-it-yourself-flow-model-in-pytorch"><span class="header-section-number">6</span> 🧪 Try It Yourself: Flow Model in Pytorch</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">7</span> References</a></li>
  <li><a href="#further-reading" id="toc-further-reading" class="nav-link" data-scroll-target="#further-reading"><span class="header-section-number">8</span> Further Reading</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./vae.html">Deep Generative Models</a></li><li class="breadcrumb-item"><a href="./flows.html">Normalizing Flows</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Normalizing Flow Models</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>In generative modeling, the objective is to learn a probability distribution over data that allows us to both <strong>generate new examples</strong> and <strong>evaluate the likelihood</strong> of observed ones. For a model to be practically useful, it must support <strong>efficient sampling</strong> and enable <strong>exact or tractable likelihood computation</strong> during training.</p>
<p><strong>A Variational Autoencoder (VAE)</strong> is a type of generative model that introduces latent variables <span class="math inline">\(z\)</span>, allowing the model to learn compact, structured representations of the data. VAEs are designed to support both sampling and likelihood estimation. However, computing the true marginal likelihood <span class="math inline">\(p(x)\)</span> is often intractable. To address this, VAEs use <strong>variational inference</strong> to approximate the posterior <span class="math inline">\(p(z \mid x)\)</span> and optimize a surrogate objective known as the <strong>Evidence Lower Bound (ELBO)</strong>. This is made possible by the <strong>reparameterization trick</strong>, which enables gradients to flow through stochastic latent variables during training.</p>
<p><strong>Normalizing flows</strong> address the limitations of VAEs by providing a way to perform exact inference and likelihood computation. They model complex data distributions using a sequence of invertible transformations applied to a simple base distribution. In this setup, a data point <span class="math inline">\(x\)</span> is generated by applying a function <span class="math inline">\(x = f(z)\)</span> to a latent variable <span class="math inline">\(z\)</span> sampled from a simple prior (e.g., a standard Gaussian). The transformation is invertible, so <span class="math inline">\(z\)</span> can be exactly recovered as <span class="math inline">\(z = f^{-1}(x)\)</span>. This structure enables direct access to both the data likelihood and latent variables using the change-of-variables formula.</p>
<p>This structure offers several advantages. First, <strong>each <span class="math inline">\(x\)</span> maps to a unique <span class="math inline">\(z\)</span></strong>, eliminating the need to marginalize over latent variables as in VAEs. Second, the <strong>change-of-variables formula</strong> enables <strong>exact computation of the likelihood</strong>, rather than approximations. Third, <strong>sampling is straightforward</strong>: draw <span class="math inline">\(z \sim p_Z(z)\)</span> from the base distribution and apply the transformation <span class="math inline">\(x = f(z)\)</span>.</p>
<p>Despite these strengths, normalizing flows have limitations. Unlike VAEs, which can learn <strong>lower-dimensional latent representations</strong>, flows require the latent and data spaces to have <strong>equal dimensionality</strong> to preserve invertibility. This means flow-based models <strong>do not perform dimensionality reduction</strong>, which can be a disadvantage in tasks where compact representations are important.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/vae_vs_flow.png" class="img-fluid figure-img"></p>
<figcaption>Comparison of VAE and Flow-based Models</figcaption>
</figure>
</div>
<p><em>VAEs compress data into a lower-dimensional latent space using an encoder, then reconstruct it with a decoder. Flow-based models use a single invertible transformation that keeps the same dimensionality between input and latent space. This enables exact inference and likelihood computation.</em></p>
<p>To understand how normalizing flows enable exact likelihood computation, we first need to explore a fundamental mathematical concept: the change-of-variable formula. This principle lies at the heart of flow models, allowing us to transform probability densities through invertible functions. We’ll begin with the 1D case and build up to the multivariate formulation.</p>
</section>
<section id="math-review" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="math-review"><span class="header-section-number">2</span> Math Review</h2>
<p>This section builds the mathematical foundation for understanding flow models, starting with change-of-variable and extending to multivariate transformations and Jacobians.</p>
<section id="change-of-variables-in-1d" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="change-of-variables-in-1d"><span class="header-section-number">2.1</span> Change of Variables in 1D</h3>
<p>Suppose we have a <strong>random variable</strong> <span class="math inline">\(z\)</span> with a known distribution <span class="math inline">\(p_Z(z)\)</span>, and we define a new variable:</p>
<p><span class="math display">\[
x = f(z)
\]</span></p>
<p>where <span class="math inline">\(f\)</span> is a <strong>monotonic, differentiable</strong> function with an inverse:</p>
<p><span class="math display">\[
z = f^{-1}(x) = h(x)
\]</span></p>
<p>Our goal is to compute the probability density function (PDF) of <span class="math inline">\(x\)</span>, denoted <span class="math inline">\(p_X(x)\)</span>, in terms of the known PDF <span class="math inline">\(p_Z(z)\)</span>.</p>
<section id="cumulative-distribution-function-cdf" class="level4" data-number="2.1.1">
<h4 data-number="2.1.1" class="anchored" data-anchor-id="cumulative-distribution-function-cdf"><span class="header-section-number">2.1.1</span> Cumulative Distribution Function (CDF)</h4>
<p>We begin with the cumulative distribution function of <span class="math inline">\(x\)</span>:</p>
<p><span class="math display">\[
F_X(x) = P(X \leq x) = P(f(Z) \leq x)
\]</span></p>
<p>Since <span class="math inline">\(f\)</span> is monotonic and invertible, this becomes:</p>
<p><span class="math display">\[
P(f(Z) \leq x) = P(Z \leq f^{-1}(x)) = F_Z(h(x))
\]</span></p>
</section>
<section id="deriving-the-pdf-via-chain-rule" class="level4" data-number="2.1.2">
<h4 data-number="2.1.2" class="anchored" data-anchor-id="deriving-the-pdf-via-chain-rule"><span class="header-section-number">2.1.2</span> Deriving the PDF via Chain Rule</h4>
<p>To obtain the PDF, we differentiate the CDF:</p>
<p><span class="math display">\[
p_X(x) = \frac{d}{dx} F_X(x) = \frac{d}{dx} F_Z(h(x))
\]</span></p>
<p>Applying the chain rule:</p>
<p><span class="math display">\[
p_X(x) = F_Z'(h(x)) \cdot h'(x) = p_Z(h(x)) \cdot h'(x)
\]</span></p>
</section>
<section id="rewrite-in-terms-of-z" class="level4" data-number="2.1.3">
<h4 data-number="2.1.3" class="anchored" data-anchor-id="rewrite-in-terms-of-z"><span class="header-section-number">2.1.3</span> Rewrite in Terms of <span class="math inline">\(z\)</span></h4>
<p>From the previous step:</p>
<p><span class="math display">\[
p_X(x) = p_Z(h(x)) \cdot h'(x)
\]</span></p>
<p>Since <span class="math inline">\(z = h(x)\)</span>, we can rewrite:</p>
<p><span class="math display">\[
p_X(x) = p_Z(z) \cdot h'(x)
\]</span></p>
<p>Now, using the <strong>inverse function theorem</strong>, we express <span class="math inline">\(h'(x)\)</span> as:</p>
<p><span class="math display">\[
h'(x) = \frac{d}{dx} f^{-1}(x) = \frac{1}{f'(z)}
\]</span></p>
<p>So the final expression becomes:</p>
<p><span class="math display">\[
p_X(x) = p_Z(z) \cdot \left| \frac{1}{f'(z)} \right|
\]</span></p>
<p>The <strong>absolute value</strong> ensures the density remains non-negative, as required for any valid probability distribution.</p>
<p>This is the fundamental concept normalizing flows use to model complex distributions by transforming simple ones.</p>
</section>
</section>
<section id="geometry-determinants-and-volume-changes" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="geometry-determinants-and-volume-changes"><span class="header-section-number">2.2</span> Geometry: Determinants and Volume Changes</h3>
<p>To further understand the multivariate change-of-variable formula, it’s helpful to first explore how linear transformations affect <strong>volume</strong> in high-dimensional spaces.</p>
<p>Let <span class="math inline">\(\mathbf{Z}\)</span> be a random vector uniformly distributed in the unit cube <span class="math inline">\([0,1]^n\)</span>, and let <span class="math inline">\(\mathbf{X} = A\mathbf{Z}\)</span>, where <span class="math inline">\(A\)</span> is a square, invertible matrix. Geometrically, the matrix <span class="math inline">\(A\)</span> maps the unit hypercube to a <strong>parallelogram</strong> in 2D or a <strong>parallelotope</strong> in higher dimensions.</p>
<p>The <strong>determinant</strong> of a square matrix tells us how the transformation <strong>scales volume</strong>. For instance, if the determinant of a <span class="math inline">\(2 \times 2\)</span> matrix is 3, applying that matrix will stretch the area of a region by a factor of 3. A negative determinant indicates a <strong>reflection</strong>, meaning the transformation also flips the orientation. When measuring volume, we care about the <strong>absolute value</strong> of the determinant.</p>
<p>The volume of the resulting parallelotope is given by:</p>
<p><span class="math display">\[
\text{Volume} = |\det(A)|
\]</span></p>
<p>This expression tells us how much the transformation <span class="math inline">\(A\)</span> scales space. For example, if <span class="math inline">\(|\det(A)| = 2\)</span>, the transformation doubles the volume.</p>
<p>To make this idea concrete, consider the illustration below. The left figure shows a uniform distribution over the unit square <span class="math inline">\([0, 1]^2\)</span>. When we apply the linear transformation <span class="math inline">\(A = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}\)</span>, each point in the square is mapped to a new location, stretching the square into a parallelogram. The area of this parallelogram — and hence the volume scaling — is given by the <strong>absolute value of the determinant</strong> <span class="math inline">\(|\det(A)| = |ad - bc|\)</span>.</p>
<div style="text-align: center;">
<img src="images/determinant_area.png" alt="Linear transformation of a unit square into a parallelogram" width="500">
<p style="color: gray; font-size: 0.95em;">
<em> A linear transformation maps a unit square to a parallelogram. </em>
</p>
</div>
<p>This geometric intuition becomes essential when we apply the same logic to probability densities. The area of the parallelogram equals the absolute value of the determinant, |det(A)|, indicating how the transformation scales area.</p>
</section>
<section id="determinants-and-probability-density" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="determinants-and-probability-density"><span class="header-section-number">2.3</span> Determinants and Probability Density</h3>
<p>Previously, we saw how a linear transformation scales volume. Now we apply the same idea to probability densities — since density is defined per unit volume, scaling the volume also affects the density.</p>
<p>To transform the density from <span class="math inline">\(\mathbf{Z}\)</span> to <span class="math inline">\(\mathbf{X}\)</span>, we use the <strong>change-of-variable formula</strong>. Since <span class="math inline">\(\mathbf{X} = A\mathbf{Z}\)</span>, the inverse transformation is <span class="math inline">\(\mathbf{Z} = A^{-1} \mathbf{X}\)</span>. This tells us how to evaluate the density at <span class="math inline">\(\mathbf{x}\)</span> by “pulling it back” through the inverse mapping. Applying the multivariate change-of-variable rule:</p>
<p><span class="math display">\[
p_X(\mathbf{x}) = p_Z(W \mathbf{x}) \cdot \left| \det(W) \right| \quad \text{where } W = A^{-1}
\]</span></p>
<p>This is directly analogous to the 1D change-of-variable rule:</p>
<p><span class="math display">\[
p_X(x) = p_Z(h(x)) \cdot |h'(x)|
\]</span></p>
<p>but now in multiple dimensions using the determinant of the <strong>inverse transformation</strong>.</p>
<p>To make this more concrete, here’s a simple 2D example demonstrating how linear transformations affect probability density.</p>
<p>Let <span class="math inline">\(\mathbf{Z}\)</span> be a random vector uniformly distributed over the unit square <span class="math inline">\([0, 1]^2\)</span>. Suppose we apply the transformation <span class="math inline">\(\mathbf{X} = A\mathbf{Z}\)</span>, where</p>
<p><span class="math display">\[
A = \begin{bmatrix}
2 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\quad \text{so that} \quad
W = A^{-1} =
\begin{bmatrix}
\frac{1}{2} &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>This transformation stretches the square horizontally, doubling its width while keeping the height unchanged. As a result, the area is doubled:<br>
<span class="math display">\[
|\det(A)| = 2 \quad \text{and} \quad |\det(W)| = \frac{1}{2}
\]</span> Since the same total probability must be spread over a larger area, the density decreases, meaning the probability per unit area is reduced due to the increased area over which the same total probability is distributed.</p>
<p>Now, let’s say <span class="math inline">\(p_Z(z) = 1\)</span> inside the unit square (a uniform distribution). To compute <span class="math inline">\(p_X(\mathbf{x})\)</span> at a point <span class="math inline">\(\mathbf{x}\)</span> in the transformed space, we use:</p>
<p><span class="math display">\[
p_X(\mathbf{x}) = p_Z(W\mathbf{x}) \cdot |\det(W)| = 1 \cdot \frac{1}{2} = \frac{1}{2}
\]</span></p>
<p>So, the transformed density is halved — the same total probability (which must remain 1) is now spread over an area that is twice as large.</p>
</section>
<section id="generalizing-to-nonlinear-transformations" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="generalizing-to-nonlinear-transformations"><span class="header-section-number">2.4</span> Generalizing to Nonlinear Transformations</h3>
<p>For <strong>nonlinear</strong> transformations <span class="math inline">\(\mathbf{x} = f(\mathbf{z})\)</span>, the idea is similar. But instead of a constant matrix <span class="math inline">\(A\)</span>, we now consider the <strong>Jacobian matrix</strong> of the function <span class="math inline">\(f\)</span>:</p>
<p><span class="math display">\[
J_f(\mathbf{z}) = \frac{\partial f}{\partial \mathbf{z}}
\]</span></p>
<p>The Jacobian matrix generalizes derivatives to multivariable functions, capturing how a transformation scales and rotates space locally through all partial derivatives. Its determinant tells us how much the transformation stretches or compresses space — acting as a local volume scaling factor.</p>
</section>
<section id="multivariate-change-of-variable" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="multivariate-change-of-variable"><span class="header-section-number">2.5</span> Multivariate Change-of-Variable</h3>
<p>Given an invertible transformation <span class="math inline">\(\mathbf{x} = f(\mathbf{z})\)</span>, the probability density transforms as:</p>
<p><span class="math display">\[
p_X(\mathbf{x}) = p_Z(f^{-1}(\mathbf{x})) \cdot \left| \det \left( \frac{\partial f^{-1}(\mathbf{x})}{\partial \mathbf{x}} \right) \right|
\]</span></p>
<p>Alternatively, in the <strong>forward form</strong> (often used during training):</p>
<p><span class="math display">\[
p_X(\mathbf{x}) = p_Z(\mathbf{z}) \cdot \left| \det \left( \frac{\partial f(\mathbf{z})}{\partial \mathbf{z}} \right) \right|^{-1}
\]</span></p>
<p>This generalizes the 1D rule and enables us to compute <strong>exact likelihoods</strong> for complex distributions as long as the transformation is invertible and differentiable. This formula is pivotal in machine learning, where transformations of probability distributions are common — such as in the implementation of normalizing flows for generative modeling.</p>
</section>
</section>
<section id="flow-model" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="flow-model"><span class="header-section-number">3</span> Flow Model</h2>
<p>A normalizing flow model defines a <strong>one-to-one and reversible transformation</strong> between observed variables <span class="math inline">\(\mathbf{x}\)</span> and latent variables <span class="math inline">\(\mathbf{z}\)</span>. This transformation is given by an invertible, differentiable function <span class="math inline">\(f_\theta\)</span>, parameterized by <span class="math inline">\(\theta\)</span>:</p>
<p><span class="math display">\[
\mathbf{x} = f_\theta(\mathbf{z}) \quad \text{and} \quad \mathbf{z} = f_\theta^{-1}(\mathbf{x})
\]</span></p>
<div style="text-align: center;">
<img src="images/Flow_Model.png" alt="Flow model showing forward and inverse transformations" style="display: block; margin: auto;">
<p style="color: gray; font-size: 0.95em;">
Flow model showing forward and inverse transformations
</p>
</div>
<p><em>Figure: A flow-based model uses a forward transformation <span class="math inline">\(f_\theta\)</span> to map from latent variables (<span class="math inline">\(\mathbf{z}\)</span>) to data (<span class="math inline">\(\mathbf{x}\)</span>), and an inverse transformation <span class="math inline">\(f_\theta^{-1}\)</span> to compute likelihoods. Adapted from class notes (XCS236, Stanford).</em></p>
<p>Because the transformation is invertible, we can apply the <strong>change-of-variable formula</strong> to compute the exact probability of <span class="math inline">\(\mathbf{x}\)</span>:</p>
<p><span class="math display">\[
p_X(\mathbf{x}; \theta) = p_Z(f_\theta^{-1}(\mathbf{x})) \cdot \left| \det \left( \frac{\partial f_\theta^{-1}(\mathbf{x})}{\partial \mathbf{x}} \right) \right|
\]</span></p>
<p>This makes it possible to evaluate <strong>exact likelihoods</strong> and learn the model via <strong>maximum likelihood estimation (MLE)</strong>.</p>
<blockquote class="blockquote">
<p><strong>Note:</strong> Both <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(\mathbf{z}\)</span> must be continuous and have the same dimensionality since the transformation must be invertible.</p>
</blockquote>
<section id="model-architecture-a-sequence-of-invertible-transformations" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="model-architecture-a-sequence-of-invertible-transformations"><span class="header-section-number">3.1</span> Model Architecture: A Sequence of Invertible Transformations</h3>
<p>The term <em>flow</em> refers to the fact that we can compose multiple invertible functions to form a more expressive transformation:</p>
<p><span class="math display">\[
\mathbf{z}_m = f_\theta^{(m)} \circ f_\theta^{(m-1)} \circ \cdots \circ f_\theta^{(1)}(\mathbf{z}_0)
\]</span></p>
<p>In this setup:</p>
<ul>
<li><span class="math inline">\(\mathbf{z}_0 \sim p_Z\)</span> is sampled from a simple base distribution (e.g., standard Gaussian)</li>
<li><span class="math inline">\(\mathbf{x} = \mathbf{z}_M\)</span> is the final transformed variable</li>
<li>The full transformation <span class="math inline">\(f_\theta\)</span> is the composition of <span class="math inline">\(M\)</span> sequential invertible functions. Each function slightly reshapes the distribution, and together they produce a highly expressive mapping from a simple base distribution to a complex one.</li>
</ul>
<p>The visuals below illustrate this idea from two angles. The first diagram illustrates the structure of a normalizing flow as a composition of invertible steps, while the second shows how this architecture reshapes simple distributions into complex ones through repeated transformations.</p>
<div style="text-align: center;">
<img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/Normalizing-flow.svg" width="700" alt="Normalizing Flow Illustration">
<p style="color: gray; font-size: 0.95em;">
<em> Adapted from Wikipedia: Mapping simple distributions to complex ones via invertible transformations. </em>
</p>
</div>
<div style="text-align: center;">
<img src="images/planar_flow_transformations.png" alt="Planar Flow Transformations" width="600">
<p style="color: gray; font-size: 0.95em;">
<em> Adapted from class notes (XCS236, Stanford), originally based on <i>Rezende &amp; Mohamed, 2016</i>. </em>
</p>
</div>
<p>The density of <span class="math inline">\(\mathbf{x}\)</span> is given by the change-of-variable formula:</p>
<p><span class="math display">\[
p_X(\mathbf{x}; \theta) = p_Z(f_\theta^{-1}(\mathbf{x})) \cdot \prod_{m=1}^M \left| \det \left( \frac{\partial (f_\theta^{(m)})^{-1}(\mathbf{z}_m)}{\partial \mathbf{z}_m} \right) \right|
\]</span></p>
<p>This approach allows the model to approximate highly complex distributions using simple building blocks.</p>
</section>
</section>
<section id="learning-and-inference" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="learning-and-inference"><span class="header-section-number">4</span> Learning and Inference</h2>
<p>Training a flow-based model is done by maximizing the log-likelihood over the dataset <span class="math inline">\(\mathcal{D}\)</span>:</p>
<p><span class="math display">\[
\max_\theta \log p_X(\mathcal{D}; \theta) = \sum_{\mathbf{x} \in \mathcal{D}} \log p_Z(f_\theta^{-1}(\mathbf{x})) + \log \left| \det \left( \frac{\partial f_\theta^{-1}(\mathbf{x})}{\partial \mathbf{x}} \right) \right|
\]</span></p>
<p><strong>Key advantages of normalizing flows:</strong></p>
<ul>
<li><strong>Exact likelihoods</strong>: No approximation needed — just apply the change-of-variable rule</li>
<li><strong>Efficient sampling</strong>: Generate new data by drawing <span class="math inline">\(\mathbf{z} \sim p_Z\)</span> and computing <span class="math inline">\(\mathbf{x} = f_\theta(\mathbf{z})\)</span></li>
<li><strong>Latent inference</strong>: Invert <span class="math inline">\(f_\theta\)</span> to compute latent codes <span class="math inline">\(\mathbf{z} = f_\theta^{-1}(\mathbf{x})\)</span>, without needing a separate encoder</li>
</ul>
<section id="computational-considerations" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="computational-considerations"><span class="header-section-number">4.1</span> Computational Considerations</h3>
<p>One challenge in training normalizing flow models is that computing the <strong>exact likelihood</strong> requires evaluating the <strong>determinant of the Jacobian matrix</strong> of the transformation:</p>
<ul>
<li>For a transformation <span class="math inline">\(f : \mathbb{R}^n \to \mathbb{R}^n\)</span>, the Jacobian is an <span class="math inline">\(n \times n\)</span> matrix.</li>
<li>Computing its determinant has a cost of <span class="math inline">\(\mathcal{O}(n^3)\)</span>, which is <strong>computationally expensive</strong> during training — especially in high dimensions.</li>
</ul>
<section id="key-insight" class="level4" data-number="4.1.1">
<h4 data-number="4.1.1" class="anchored" data-anchor-id="key-insight"><span class="header-section-number">4.1.1</span> Key Insight</h4>
<p>To make normalizing flows scalable, we design transformations where the <strong>Jacobian has a special structure</strong> that makes the determinant <strong>easy to compute</strong>.</p>
<p>For example: - If the Jacobian is a <strong>triangular matrix</strong>, the determinant is just the <strong>product of the diagonal entries</strong>, which can be computed in <span class="math inline">\(\mathcal{O}(n)\)</span> time. - This works because in a triangular matrix, all the off-diagonal elements are zero — so the determinant simplifies significantly.</p>
<p>In practice, flow models like <strong>RealNVP</strong> and <strong>MAF</strong> are designed so that each output dimension <span class="math inline">\(x_i\)</span> depends only on some subset of the input dimensions <span class="math inline">\(z_{\leq i}\)</span> (for lower triangular structure) or <span class="math inline">\(z_{\geq i}\)</span> (for upper triangular structure). This results in a Jacobian of the form:</p>
<p><span class="math display">\[
J = \frac{\partial \mathbf{f}}{\partial \mathbf{z}} =
\begin{pmatrix}
\frac{\partial f_1}{\partial z_1} &amp; 0 &amp; \cdots &amp; 0 \\
\ast &amp; \frac{\partial f_2}{\partial z_2} &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\ast &amp; \ast &amp; \cdots &amp; \frac{\partial f_n}{\partial z_n}
\end{pmatrix}
\]</span></p>
<p>Because of this triangular structure, computing the determinant becomes as simple as multiplying the diagonal terms:</p>
<p><span class="math display">\[
\det(J) = \prod_{i=1}^{n} \frac{\partial f_i}{\partial z_i}
\]</span></p>
<p>This is why many modern flow models rely on <strong>coupling layers</strong> or <strong>autoregressive masking</strong>: they preserve invertibility and enable efficient, exact likelihood computation.</p>
</section>
</section>
</section>
<section id="types-of-flow-architectures" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="types-of-flow-architectures"><span class="header-section-number">5</span> Types of Flow Architectures</h2>
<p>This section introduces common architectural families used in normalizing flows, highlighting their core ideas, strengths, and limitations.</p>
<section id="elementwise-flows" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="elementwise-flows"><span class="header-section-number">5.1</span> Elementwise Flows</h3>
<ul>
<li><strong>Idea</strong>: Apply a simple invertible function to each variable independently.</li>
<li><strong>Examples</strong>: Leaky ReLU, Softplus, ELU.</li>
<li><strong>Strengths</strong>: Extremely fast; easy to implement; analytically tractable.</li>
<li><strong>Limitations</strong>: Cannot model interactions or dependencies between variables.</li>
</ul>
</section>
<section id="linear-flows" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="linear-flows"><span class="header-section-number">5.2</span> Linear Flows</h3>
<ul>
<li><strong>Idea</strong>: Apply a linear transformation using an invertible matrix (e.g., permutation, rotation, LU decomposition).</li>
<li><strong>Examples</strong>: Glow’s 1x1 Convolution, LU flows.</li>
<li><strong>Strengths</strong>: Efficiently models global dependencies; can be used to permute variables.</li>
<li><strong>Limitations</strong>: Limited expressiveness when used alone.</li>
</ul>
</section>
<section id="coupling-flows" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="coupling-flows"><span class="header-section-number">5.3</span> Coupling Flows</h3>
<ul>
<li><strong>Idea</strong>: Split the input into two parts. One half remains unchanged while the other is transformed based on it.</li>
<li><strong>Examples</strong>: NICE (additive), RealNVP (affine).</li>
<li><strong>Strengths</strong>: Easy to invert and compute Jacobians; scalable to high dimensions.</li>
<li><strong>Limitations</strong>: Requires stacking multiple layers to mix information across all dimensions.</li>
</ul>
</section>
<section id="autoregressive-flows" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="autoregressive-flows"><span class="header-section-number">5.4</span> Autoregressive Flows</h3>
<ul>
<li><strong>Idea</strong>: Model the transformation of each variable conditioned on the previous ones in a fixed order.</li>
<li><strong>Examples</strong>: Masked Autoregressive Flow (MAF), Inverse Autoregressive Flow (IAF).</li>
<li><strong>Strengths</strong>: Highly expressive; models arbitrary dependencies.</li>
<li><strong>Limitations</strong>: Slower sampling or density evaluation depending on flow direction.</li>
</ul>
</section>
<section id="residual-flows" class="level3" data-number="5.5">
<h3 data-number="5.5" class="anchored" data-anchor-id="residual-flows"><span class="header-section-number">5.5</span> Residual Flows</h3>
<ul>
<li><strong>Idea</strong>: Add residual connections while enforcing invertibility (e.g., using constraints on Jacobian eigenvalues).</li>
<li><strong>Examples</strong>: Planar flows, Radial flows, Residual Flows (Behrmann et al.).</li>
<li><strong>Strengths</strong>: Flexible and capable of complex transformations.</li>
<li><strong>Limitations</strong>: May require care to ensure invertibility; harder to train.</li>
</ul>
</section>
<section id="continuous-flows" class="level3" data-number="5.6">
<h3 data-number="5.6" class="anchored" data-anchor-id="continuous-flows"><span class="header-section-number">5.6</span> Continuous Flows</h3>
<ul>
<li><strong>Idea</strong>: Model the transformation as the solution to a differential equation parameterized by a neural network.</li>
<li><strong>Examples</strong>: Neural ODEs, FFJORD.</li>
<li><strong>Strengths</strong>: Highly flexible; enables continuous-time modeling.</li>
<li><strong>Limitations</strong>: Computationally expensive; uses ODE solvers during training and inference.</li>
</ul>
<hr>
<p>These architectures can be mixed and matched in real-world models to balance expressiveness, efficiency, and tractability. Each comes with trade-offs, and their selection often depends on the task and data at hand.</p>
<p>In the rest of this article, we focus on <strong>Coupling Flows</strong>, briefly introducing NICE and then diving deeper into the structure, intuition, and implementation details of <strong>RealNVP</strong>.</p>
</section>
<section id="nice-nonlinear-independent-components-estimation" class="level3" data-number="5.7">
<h3 data-number="5.7" class="anchored" data-anchor-id="nice-nonlinear-independent-components-estimation"><span class="header-section-number">5.7</span> NICE: Nonlinear Independent Components Estimation</h3>
<p>The NICE (Nonlinear Independent Components Estimation) model, introduced by Laurent Dinh, David Krueger, and Yoshua Bengio in 2014, is a foundational work in the development of normalizing flows.</p>
<p>It provides a framework for transforming complex high-dimensional data into a simpler latent space (often a standard Gaussian), enabling both <strong>exact likelihood estimation</strong> and <strong>sampling</strong> — two fundamental goals in generative modeling.</p>
<section id="core-concepts" class="level4" data-number="5.7.1">
<h4 data-number="5.7.1" class="anchored" data-anchor-id="core-concepts"><span class="header-section-number">5.7.1</span> Core Concepts</h4>
<ul>
<li><p><strong>Invertible Transformations</strong>:<br>
NICE constructs a chain of invertible functions to map inputs to latent variables. This ensures that both the forward and inverse transformations are tractable.</p></li>
<li><p><strong>Additive Coupling Layers</strong>:<br>
The model partitions the input into two parts and applies an additive transformation to one part using a function of the other. This design yields a triangular Jacobian with determinant 1, making log-likelihood computation efficient.</p></li>
<li><p><strong>Volume-Preserving Mapping</strong>:<br>
Because additive coupling layers do not scale the space, NICE preserves volume — i.e., the Jacobian determinant is exactly 1. While this limits expressiveness, it simplifies training and inference.</p></li>
<li><p><strong>Scaling Layer (Optional)</strong>:<br>
The original NICE paper includes an optional scaling layer at the end to allow some volume change per dimension.</p></li>
<li><p><strong>Exact Log-Likelihood</strong>:<br>
Unlike VAEs or GANs, which rely on approximations, NICE enables <strong>exact</strong> evaluation of the log-likelihood, making it a fully probabilistic, likelihood-based model.</p></li>
</ul>
</section>
<section id="additive-coupling-layer" class="level4" data-number="5.7.2">
<h4 data-number="5.7.2" class="anchored" data-anchor-id="additive-coupling-layer"><span class="header-section-number">5.7.2</span> Additive Coupling Layer</h4>
<p>To make the transformation invertible and computationally efficient, NICE splits the input vector into two parts. One part is kept unchanged, while the other part is modified using a function of the unchanged part. This way, we can easily reverse the process because we always know what was kept intact.</p>
<p>Let’s partition the input <span class="math inline">\(\mathbf{z} \in \mathbb{R}^n\)</span> into two subsets: <span class="math inline">\(\mathbf{z}_{1:d}\)</span> and <span class="math inline">\(\mathbf{z}_{d+1:n}\)</span> for some <span class="math inline">\(1 \leq d &lt; n\)</span>.</p>
<ul>
<li><strong>Forward Mapping</strong> <span class="math inline">\(\mathbf{z} \mapsto \mathbf{x}\)</span>:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{x}_{1:d} &amp;= \mathbf{z}_{1:d} \quad \text{(identity transformation)} \\
\mathbf{x}_{d+1:n} &amp;= \mathbf{z}_{d+1:n} + m_\theta(\mathbf{z}_{1:d})
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(m_\theta(\cdot)\)</span> is a neural network with parameters <span class="math inline">\(\theta\)</span>, <span class="math inline">\(d\)</span> input units, and <span class="math inline">\(n - d\)</span> output units.</p>
<ul>
<li><strong>Inverse Mapping</strong> <span class="math inline">\(\mathbf{x} \mapsto \mathbf{z}\)</span>:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{z}_{1:d} &amp;= \mathbf{x}_{1:d} \quad \text{(identity transformation)} \\
\mathbf{z}_{d+1:n} &amp;= \mathbf{x}_{d+1:n} - m_\theta(\mathbf{x}_{1:d})
\end{aligned}
\]</span></p>
<ul>
<li><strong>Jacobian</strong> of the forward mapping:</li>
</ul>
<p>The Jacobian matrix captures how much the transformation stretches or compresses space. Because the unchanged subset passes through as-is and the transformation is purely additive (no scaling), the Jacobian is triangular with 1s on the diagonal — so its determinant is 1 — meaning the transformation preserves volume.</p>
<p><span class="math display">\[
J = \frac{\partial \mathbf{x}}{\partial \mathbf{z}} =
\begin{pmatrix}
I_d &amp; 0 \\
\frac{\partial m_\theta}{\partial \mathbf{z}_{1:d}} &amp; I_{n-d}
\end{pmatrix}
\]</span></p>
<p><span class="math display">\[
\det(J) = 1
\]</span></p>
<p>Hence, additive coupling is a <strong>volume-preserving transformation</strong>.</p>
</section>
<section id="rescaling-layer" class="level4" data-number="5.7.3">
<h4 data-number="5.7.3" class="anchored" data-anchor-id="rescaling-layer"><span class="header-section-number">5.7.3</span> Rescaling Layer</h4>
<p>To overcome the limitation of fixed volume, NICE adds a diagonal scaling transformation at the end, allowing the model to contract or expand space. This is not part of the coupling layers, but is crucial to increase flexibility.</p>
<ul>
<li><strong>Forward Mapping</strong>:</li>
</ul>
<p><span class="math display">\[
x_i = s_i z_i \quad \text{with} \quad s_i &gt; 0
\]</span></p>
<ul>
<li><strong>Inverse Mapping</strong>:</li>
</ul>
<p><span class="math display">\[
z_i = \frac{x_i}{s_i}
\]</span></p>
<ul>
<li><strong>Jacobian</strong>:</li>
</ul>
<p><span class="math display">\[
J = \text{diag}(\mathbf{s})
\quad \Rightarrow \quad
\det(J) = \prod_{i=1}^n s_i
\]</span></p>
<p>However, the volume-preserving property of NICE limits its expressiveness. RealNVP extends this idea by introducing affine coupling layers that enable volume changes during transformation.</p>
</section>
</section>
<section id="real-nvp-non-volume-preserving-extension-of-nice" class="level3" data-number="5.8">
<h3 data-number="5.8" class="anchored" data-anchor-id="real-nvp-non-volume-preserving-extension-of-nice"><span class="header-section-number">5.8</span> Real-NVP: Non-Volume Preserving Extension of NICE</h3>
<p>Real-NVP (Dinh et al., 2017) extends NICE by introducing a <strong>scaling function</strong> that allows the model to change volume, enabling more expressive transformations. This is achieved using <strong>affine coupling layers</strong> that apply learned scaling and translation functions to part of the input while keeping the rest unchanged.</p>
<div style="text-align: center;">
<img src="images/coupling-layer.png" alt="Affine Coupling Layer in RealNVP" width="700">
<p style="color: gray; font-size: 0.95em;">
<em> Visualization of a single affine coupling layer in RealNVP. The identity path and affine transform structure allow exact inversion and efficient computation. </em>
</p>
</div>
<p>We partition the input <span class="math inline">\(\mathbf{z} \in \mathbb{R}^n\)</span> into two subsets: <span class="math inline">\(\mathbf{z}_{1:d}\)</span> and <span class="math inline">\(\mathbf{z}_{d+1:n}\)</span>.</p>
<ul>
<li><strong>Forward Mapping</strong> <span class="math inline">\(\mathbf{z} \mapsto \mathbf{x}\)</span>:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{x}_{1:d} &amp;= \mathbf{z}_{1:d} \quad \text{(identity transformation)} \\\\
\mathbf{x}_{d+1:n} &amp;= \mathbf{z}_{d+1:n} \odot \exp(\alpha_\theta(\mathbf{z}_{1:d})) + \mu_\theta(\mathbf{z}_{1:d})
\end{aligned}
\]</span></p>
<p>Here, <span class="math inline">\(\boldsymbol{\alpha}_\theta(\cdot)\)</span> and <span class="math inline">\(\boldsymbol{\mu}_\theta(\cdot)\)</span> are <strong>neural networks with parameters <span class="math inline">\(\theta\)</span></strong> that take the unchanged subset <span class="math inline">\(\mathbf{z}_{1:d}\)</span> as input and produce scale and shift parameters, respectively, for the transformed subset <span class="math inline">\(\mathbf{z}_{d+1:n}\)</span>. These functions enable flexible, learnable affine transformations while preserving invertibility.</p>
<ul>
<li><strong>Inverse Mapping</strong> <span class="math inline">\(\mathbf{x} \mapsto \mathbf{z}\)</span>:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{z}_{1:d} &amp;= \mathbf{x}_{1:d} \quad \text{(identity transformation)} \\\\
\mathbf{z}_{d+1:n} &amp;= \left( \mathbf{x}_{d+1:n} - \mu_\theta(\mathbf{x}_{1:d}) \right) \odot \exp(-\alpha_\theta(\mathbf{x}_{1:d}))
\end{aligned}
\]</span></p>
<p>The inverse mapping recovers the latent variable <span class="math inline">\(\mathbf{z}\)</span> from the data <span class="math inline">\(\mathbf{x}\)</span>. The first subset <span class="math inline">\(\mathbf{x}_{1:d}\)</span> remains unchanged and directly becomes <span class="math inline">\(\mathbf{z}_{1:d}\)</span>. To reconstruct <span class="math inline">\(\mathbf{z}_{d+1:n}\)</span>, we first subtract the shift <span class="math inline">\(\boldsymbol{\mu}_\theta(\mathbf{x}_{1:d})\)</span> from <span class="math inline">\(\mathbf{x}_{d+1:n}\)</span>, and then apply an elementwise rescaling using <span class="math inline">\(\exp(-\boldsymbol{\alpha}_\theta(\mathbf{x}_{1:d}))\)</span>. This inversion relies on the same neural networks used in the forward pass and ensures that the transformation is exactly reversible.</p>
<ul>
<li><strong>Jacobian of Forward Mapping</strong>:</li>
</ul>
<p><span class="math display">\[
J = \frac{\partial \mathbf{x}}{\partial \mathbf{z}} =
\begin{pmatrix}
I_d &amp; 0 \\\\
\frac{\partial \mathbf{x}_{d+1:n}}{\partial \mathbf{z}_{1:d}} &amp; \operatorname{diag}\left(\exp(\alpha_\theta(\mathbf{z}_{1:d}))\right)
\end{pmatrix}
\]</span></p>
<p>The Jacobian matrix of the RealNVP forward transformation has a special block structure due to the design of the affine coupling layer:</p>
<ul>
<li><p><strong>Upper left block</strong>: <span class="math inline">\(\mathbf{I}_d\)</span><br>
This corresponds to the partial derivatives of <span class="math inline">\(\mathbf{x}_{1:d}\)</span> with respect to <span class="math inline">\(\mathbf{z}_{1:d}\)</span>. Since the first <span class="math inline">\(d\)</span> variables are passed through unchanged (<span class="math inline">\(\mathbf{x}_{1:d} = \mathbf{z}_{1:d}\)</span>), their derivatives form an identity matrix.</p></li>
<li><p><strong>Upper right block</strong>: <span class="math inline">\(0\)</span><br>
These derivatives are zero because <span class="math inline">\(\mathbf{x}_{1:d}\)</span> does not depend on <span class="math inline">\(\mathbf{z}_{d+1:n}\)</span> at all — they’re completely decoupled.</p></li>
<li><p><strong>Lower right block: (diagonal)</strong><br>
Each element of <span class="math inline">\(\mathbf{x}_{d+1:n}\)</span> is scaled elementwise by <span class="math inline">\(\exp\left(\left[\alpha_\theta(\mathbf{z}_{1:d})\right]_i\right)\)</span>. This means the Jacobian of this part is a diagonal matrix, where each diagonal entry is the corresponding scale factor.</p></li>
<li><p><strong>Lower left block</strong>:<br>
This part can contain non-zero values because <span class="math inline">\(\mathbf{x}_{d+1:n}\)</span> depends on <span class="math inline">\(\mathbf{z}_{1:d}\)</span> via the neural networks. But thanks to the triangular structure of the Jacobian, we don’t need this block to compute the determinant.</p></li>
</ul>
<div style="text-align: center;">
<img src="images/realnvp_jacobian_upper_triangular.png" alt="Jacobian of RealNVP Forward Mapping" width="700">
<p style="color: gray; font-size: 0.95em;">
<em> Jacobian of the RealNVP forward transformation. Upper triangular structure arises because the first subset is unchanged, while the second is scaled and shifted based on the first. </em>
</p>
</div>
<section id="why-this-structure-matters" class="level4" data-number="5.8.1">
<h4 data-number="5.8.1" class="anchored" data-anchor-id="why-this-structure-matters"><span class="header-section-number">5.8.1</span> Why This Structure Matters</h4>
<p>Because the Jacobian is <strong>triangular</strong>, its determinant is simply the product of the diagonal entries.</p>
<p><span class="math display">\[
\det(J) = \prod_{i=d+1}^{n} \exp\left( \alpha_\theta(\mathbf{z}_{1:d})_i \right)
= \exp\left( \sum_{i=d+1}^{n} \alpha_\theta(\mathbf{z}_{1:d})_i \right)
\]</span></p>
<p>In log-space, this becomes a sum:</p>
<p><span class="math display">\[
\log \det(J) = \sum_{i=d+1}^{n} \alpha_\theta(\mathbf{z}_{1:d})_i
\]</span></p>
<p>This makes the computation of log-likelihoods fast and tractable.</p>
<p>Taking the product of the diagonal entries gives us a measure of <strong>how much the transformation expands or contracts local volume</strong>. If the determinant is greater than 1, the transformation expands space; if it’s less than 1, it contracts space. Since the determinant is not fixed, RealNVP performs a <strong>non-volume preserving transformation</strong> — allowing it to model more complex distributions than NICE, which preserves volume by design.</p>
</section>
<section id="stacking-coupling-layers" class="level4" data-number="5.8.2">
<h4 data-number="5.8.2" class="anchored" data-anchor-id="stacking-coupling-layers"><span class="header-section-number">5.8.2</span> Stacking Coupling Layers</h4>
<p>Each coupling layer only transforms part of the input. To ensure that <strong>every dimension is eventually updated</strong>, RealNVP stacks multiple coupling layers and <strong>alternates the masking pattern</strong> between them.</p>
<ul>
<li>In one layer, the first half is fixed, and the second half is transformed.</li>
<li>In the next layer, the roles are reversed.</li>
</ul>
<p>This alternating structure ensures: - All input dimensions are updated across layers - The full transformation remains invertible - The total log-determinant is the <strong>sum of the log-determinants</strong> of each layer</p>
</section>
<section id="realnvp-in-action-two-moons" class="level4" data-number="5.8.3">
<h4 data-number="5.8.3" class="anchored" data-anchor-id="realnvp-in-action-two-moons"><span class="header-section-number">5.8.3</span> RealNVP in Action (Two Moons)</h4>
<p>The following plots illustrate how RealNVP transforms data in practice:</p>
<div style="text-align: center;">
<img src="images/realnvp_result.png" alt="RealNVP Two Moons Visualization" width="800">
<p style="color: gray; font-size: 0.95em;">
<em> Top-left: Original two-moons data (X)<br>
Top-right: Encoded latent space (Z) Bottom-left: Latent samples from base distribution<br>
Bottom-right: Generated samples mapped back to (X) space<br>
</em>
</p>
</div>
</section>
<section id="summary" class="level4" data-number="5.8.4">
<h4 data-number="5.8.4" class="anchored" data-anchor-id="summary"><span class="header-section-number">5.8.4</span> Summary</h4>
<p>To recap the key distinctions between NICE and RealNVP, here’s a side-by-side comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 42%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>NICE</th>
<th>RealNVP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Type of coupling</strong></td>
<td>Additive</td>
<td>Affine (scaling + shift)</td>
</tr>
<tr class="even">
<td><strong>Volume change</strong></td>
<td>Only possible with rescaling layer</td>
<td>Built into each coupling layer</td>
</tr>
<tr class="odd">
<td><strong>Jacobian determinant</strong></td>
<td>1 (in coupling layers)</td>
<td>Varies (depends on learned scale)</td>
</tr>
<tr class="even">
<td><strong>Expressiveness</strong></td>
<td>Limited (volume-preserving layers)</td>
<td>Higher (learns scale &amp; shift)</td>
</tr>
<tr class="odd">
<td><strong>Log-likelihood</strong></td>
<td>Exact</td>
<td>Exact</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
</section>
<section id="try-it-yourself-flow-model-in-pytorch" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="try-it-yourself-flow-model-in-pytorch"><span class="header-section-number">6</span> 🧪 Try It Yourself: Flow Model in Pytorch</h2>
<p>You can explore a minimal PyTorch implementation of a normalizing flow model:</p>
<ul>
<li>📘 <a href="https://github.com/changezakram/Deep-Generative-Models/blob/main/normalizing_flow_pytorch.ipynb"><strong>View Notebook on GitHub</strong></a></li>
<li>🚀 <a href="https://colab.research.google.com/github/changezakram/Deep-Generative-Models/blob/main/normalizing_flow_pytorch.ipynb"><strong>Run in Google Colab</strong></a></li>
</ul>
</section>
<section id="references" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="references"><span class="header-section-number">7</span> References</h2>
<p>[1] Stanford CS236 Notes. “<a href="https://deepgenerativemodels.github.io/">Normalizing Flows</a>”</p>
<p>[2] UT Austin Calculus Notes. “<a href="https://services.math.duke.edu/~jtwong/calculus/change-of-variables.html">Jacobian and Change of Variables</a>”</p>
<p>[3] Danilo Jimenez Rezende, and Shakir Mohamed. “<a href="https://arxiv.org/abs/1505.05770">Variational Inference with Normalizing Flows</a>”</p>
<p>[4] Kobyzev, Prince, and Brubaker. “<a href="https://arxiv.org/abs/1908.09257">Normalizing Flows: An Introduction and Review of Current Methods</a>”</p>
<p>[5] Wikipedia. “<a href="https://en.wikipedia.org/wiki/Normalizing_flow">Normalizing Flow</a>”</p>
</section>
<section id="further-reading" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="further-reading"><span class="header-section-number">8</span> Further Reading</h2>
<p>[1] George Papamakarios et al.&nbsp;“<a href="https://arxiv.org/abs/1912.02762">Normalizing Flows for Probabilistic Modeling and Inference</a>”</p>
<p>[2] Lilian Weng. “<a href="https://lilianweng.github.io/posts/2018-08-12-vae.html#normalizing-flows">Flow-based Models</a>”</p>
<p>[3] Eric Jang. “<a href="https://blog.evjang.com/2018/01/nf1.html">Normalizing Flows Tutorial – Part 1</a>”</p>
<p>[4] Eric Jang. “<a href="https://blog.evjang.com/2018/01/nf2.html">Normalizing Flows Tutorial – Part 2</a>”</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./coming-soon.html" class="pagination-link" aria-label="Generative Adversarial Networks (GANs) [Coming Soon]">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Generative Adversarial Networks (GANs) [Coming Soon]</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ebm.html" class="pagination-link" aria-label="Energy-Based Models (EBMs)">
        <span class="nav-page-text">Energy-Based Models (EBMs)</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>